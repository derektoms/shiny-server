contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
(par(mfrow=c(3,5),mar=c(0.1,0.1,0.1,0.1))
)
par(mfrow=c(3,5),mar=c(0.1,0.1,0.1,0.1))
contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
par(mfrow=c(3,5),mar=c(0.3,0.3,0.3,0.3))
contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
par(mfrow=c(3,5),mar=c(0.8,0.8,0.8,0.8))
contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
par(mfrow=c(3,5),mar=c(4,4,4,4))
contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
par(mfrow=c(3,5),mar=c(3,3,3,3))
contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
par(mfrow=c(3,5),mar=c(3.5,3.5,3.5,3.5))
contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
par(mfrow=c(3,5),mar=c(4,4,4,4))
contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
par(mfrow=c(3,5),mar=c(3,3,3,3))
contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
par(mfrow=c(3,5),mar=c(3,4,3,3))
contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
contour(INS.SO, ~x3+x4, at=xs(INS.SO),image=TRUE)
contour(INS.SO, ~x3+x5, at=xs(INS.SO),image=TRUE)
persp(INS.SO, ~x3+x4, at=xs(INS.SO),image=TRUE)
persp(INS.SO, ~x3+x4, at=xs(INS.SO),image=TRUE,col="rainbow")
persp(INS.SO, ~x3+x4, at=xs(INS.SO),image=TRUE,col="red")
persp(INS.SO, ~x3+x4, at=xs(INS.SO),col="red")
persp(INS.SO, ~x3+x4, at=xs(INS.SO),col=colorspace::terrain_hcl)
persp(INS.SO, ~x3+x4, at=xs(INS.SO),col=rainbow(40))
persp(INS.SO, ~x3+x4, at=xs(INS.SO),col=terrain.colors(40))
persp(INS.SO, ~x3+x5, at=xs(INS.SO),col=terrain.colors(40))
persp(INS.SO, ~x3+x5, at=xs(INS.SO),col=terrain.colors(40),zlim=5)
persp(INS.SO, ~x3+x5, at=xs(INS.SO),col=terrain.colors(40),zlim=c(0,5))
persp(INS.SO, ~x3+x5, at=xs(INS.SO),col=terrain.colors(40),zlim=c(-2,5))
persp(INS.SO, ~x3+x5, at=xs(INS.SO),col=terrain.colors(40),zlim=c(-0.2,5))
persp(INS.SO, ~x3+x5, at=xs(INS.SO),col=terrain.colors(40),zlim=c(-0.8,5))
persp(INS.SO, ~x3+x4, at=xs(INS.SO),col=terrain.colors(40),zlim=c(-0.8,5))
par(mfrow=c(3,5),mar=c(3,4,3,3))
contour(INS.SO, ~x1+x2+x3+x4+x5+x6, at=xs(INS.SO),image=TRUE)
csvf<-read.csv('~/Dropbox/Pseudoislet Optimization/DSD_pseudoislets/2018-03 Runs/2018-04-06_CCD_pseudoislets_analysis.csv')
head(csvf)
csvf<-read.csv('~/Dropbox/Pseudoislet Optimization/DSD_pseudoislets/2018-03 Runs/2018-04-06_CCD_pseudoislets_analysis.csv')
head(csvf)
highP<-csvf[which(id=='R264'),]
summary(csvf)
highP<-csvf[which(csvf$id=='R264'),]
hihgP
highP
CCDout<- coded.data(highP,#
    x1~(size-500)/250, #cells per agg#
    x2~(igf1-25)/25, # nM#
    x3~(nic-3)/3, # mM#
    x4~(glp1-5)/5, # nM#
    x5~(emr-50)/50, # µM#
    x6~(actA-3)/3 # nM#
   )
CCD.FO <- rsm(ER~FO(x1,x2,x3,x4,x5,x6),data=CCDout)
CCD.FO <- rsm(ER~FO(x1,x2,x3,x4,x5,x6),data=CCDout)
CCD.FO <- rsm(ER.fg.cell~FO(x1,x2,x3,x4,x5,x6),data=CCDout)
summary(CCD.FO)
CCD.SO <- rsm(ER.fg.cell~SO(x1,x2,x3,x4,x5,x6),data=CCDout)
summary(CCD.SO)
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCD.SO))
(par(mfrow=c(3,5))
(par(mfrow=c(3,5)
par(mfrow=c(3,5))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCD.SO))
contour(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCD.SO),image=TRUE)
par(mfrow=c(3,5))
contour(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCD.SO),image=TRUE)
par(mfrow=c(3,5))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6)
highP<-csvf[which(csvf$id!='R264'),]
highP<-csvf[which(csvf$id=='R264'),]
lowP<-csvf[which(csvf$id!='R264'),]
CCDlo.FO <- rsm(ER.fg.cell~FO(x1,x2,x3,x4,x5,x6),data=lPout)
lPout<- coded.data(lowP,#
    x1~(size-500)/250, #cells per agg#
    x2~(igf1-25)/25, # nM#
    x3~(nic-3)/3, # mM#
    x4~(glp1-5)/5, # nM#
    x5~(emr-50)/50, # µM#
    x6~(actA-3)/3 # nM#
   )
CCDlo.FO <- rsm(ER.fg.cell~FO(x1,x2,x3,x4,x5,x6),data=lPout)#
CCDlo.SO <- rsm(ER.fg.cell~SO(x1,x2,x3,x4,x5,x6),data=lPout)
summary(CCDlo.FO)
summary(CCDlo.SO)
persp(CCDlo.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO))
setwd('/Users/derektoms/Desktop')
(par(mfrow=c(3,5))
setwd('/Users/derektoms/Desktop')
par(mfrow=c(3,5))#
persp(CCDlo.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO))
persp(CCDlo.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO))
persp(CCDlo.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=40)
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140)
(par(mfrow=c(3,5),mar=c(3,4,3,3))
par(mfrow=c(3,5),mar=c(3,4,3,3))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140)
par(mfrow=c(3,5),mar=c(4,4,4,4))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140)
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140,ticktype='simple')
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140,ticktype='simple',zlim=c(-40,40))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140,ticktype='simple',zlim=c(-60,60))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140,ticktype='simple',zlim=c(-50,50))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140,ticktype='simple',zlim=c(-55,50))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140,ticktype='simple',zlim=c(-55,30))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140,ticktype='simple',zlim=c(-55,35))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=140,ticktype='simple',zlim=c(-55,38))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=80,ticktype='simple',zlim=c(-55,38))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=120,ticktype='simple',zlim=c(-55,38))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=150,ticktype='simple',zlim=c(-55,38))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=190,ticktype='simple',zlim=c(-55,38))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rainbow(40),theta=190,ticktype='simple',zlim=c(-55,38))
library(RColorBrewer)
brewer.pal("spectral",9)
brewer.pal(11,"spectral")
brewer.pal(11,"Spectral")
mycol<-brewer.pal("spectral",9)
mycol<-brewer.pal(11,"Spectral")
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=mycol,theta=190,ticktype='simple')
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=-mycol,theta=190,ticktype='simple')
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rev(mycol),theta=190,ticktype='simple')
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rev(mycol),theta=210,ticktype='simple')
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rev(mycol),theta=10,ticktype='simple')
par(mfrow=c(3,5),mar=c(4,4,4,4))
persp(CCD.SO, ~x1+x2+x3+x4+x5+x6, at=xs(CCDlo.SO),col=rev(mycol),theta=10,ticktype='simple')
?persp
shinyApp(ui,server)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
 ## Outputs#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
 # output$filteredgse <- DT::renderDataTable({#
 #     filtered_gse()[,c(1,2,7)]}, options=list(searching=TRUE, pageLength=20))#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
  output$GSEtoGSMlist <- renderTable(#
    if (input$GSE_GSM == 0)#
      return ()#
    else#
      return (filter(gse_gsm,gse %in% gse_to_keep()$gse)))#
  output$gsm_table <- DT::renderDataTable({#
    #if (input$Assign == 0)#
    #  return (gsm_annotated())#
    #else#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
#
  output$finishedtable <- renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectColumns(7)#
  })#
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
ui <- fluidPage(#
  tags$head(tags$script(HTML(jscode))),#
#
  navbarPage("receptoR",#
              theme = "sandstone.css",#
    # Search for GSE  ------------------------------------------------------------------------------              #
            tabPanel("Select GEO data series (GSE)",  #search GSE, and select which to include#
                sidebarLayout(#
                    sidebarPanel(#
                        # Search for datasets ------------------------------------------------------#
                        h4("1. Search for GEO data series (GSE)"),#
                        radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
                        tagAppendAttributes(#
                            textInput("Key", "Enter search terms, separated by commas", value = ""),#
                            `data-proxy-click` = "Search"#
                        ),#
                        actionButton("Search", "Search"),#
                        hr(),#
                        # Define categories --------------------------------------------------------#
                        h4("3. Define the categories that you wish to assign each sample (GSM) for comparison."),#
                        textInput("cat1", "Define Category 1"),#
                        textInput("cat2", "Define Category 2"),#
                        textInput("cat3", "Define Category 3")#
                    ),#
                    # Filtered GSE list -----------------------------------------------------------#
                    mainPanel(#
                        h4("2. Highlight the desired search results (GSE) and click 'Retrieve GSM' to proceed"),#
                        actionButton("getGSM", "Retrieve GSM"),#
                        helpText("Do not click 'finish' until all selections have been made. This button removes the unselected rows and generates a new table on the next page."),#
                        DT::dataTableOutput("filteredgse")#
                    )#
                )#
            ),#
            # Assign samples to categories ------------------------------------------------------#
              tabPanel("Assign samples (GSM) to categories", #
                      h4("4. Highlight the desired search results and click 'assign' to assign them to the specificed category"),#
                      uiOutput("categorySelect"),#
                      actionButton("Assign", "Assign Categories"),#
                      verbatimTextOutput("selectedRows"), ## doesn't seem to be working#
                      actionButton("Remove", "Finalize selections and remove not included"),#
                      helpText("Do not click 'finish' until all selections have been made. #
                               This button removes the unselected rows and generates a new table on the next page."),#
                      DT::dataTableOutput("gsm_table")#
             ),#
             # This will be where the CEL files are downloaded (confirmation, etc) ------------#
             tabPanel("Selection details", uiOutput("page4"), #
                      tableOutput("finishedtable"),#
                      actionButton("downloadCEL","Download CEL files")#
             )#
  )#
)
shinyApp(ui,server)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
ui <- fluidPage(#
  tags$head(tags$script(HTML(jscode))),#
#
  navbarPage("receptoR",#
              theme = "sandstone.css",#
    # Search for GSE  ------------------------------------------------------------------------------              #
            tabPanel("Select GEO data series (GSE)",  #search GSE, and select which to include#
                sidebarLayout(#
                    sidebarPanel(#
                        # Search for datasets ------------------------------------------------------#
                        h4("1. Search for GEO data series (GSE)"),#
                        radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
                        tagAppendAttributes(#
                            textInput("Key", "Enter search terms, separated by commas", value = ""),#
                            `data-proxy-click` = "Search"#
                        ),#
                        actionButton("Search", "Search"),#
                        hr(),#
                        # Define categories --------------------------------------------------------#
                        h4("3. Define the categories that you wish to assign each sample (GSM) for comparison."),#
                        textInput("cat1", "Define Category 1"),#
                        textInput("cat2", "Define Category 2"),#
                        textInput("cat3", "Define Category 3")#
                    ),#
                    # Filtered GSE list -----------------------------------------------------------#
                    mainPanel(#
                        h4("2. Highlight the desired search results (GSE) and click 'Retrieve GSM' to proceed"),#
                        actionButton("getGSM", "Retrieve GSM"),#
                        helpText("Do not click 'finish' until all selections have been made. This button removes the unselected rows and generates a new table on the next page."),#
                        DT::dataTableOutput("filteredgse")#
                    )#
                )#
            ),#
            # Assign samples to categories ------------------------------------------------------#
              tabPanel("Assign samples (GSM) to categories", #
                      h4("4. Highlight the desired search results and click 'assign' to assign them to the specificed category"),#
                      uiOutput("categorySelect"),#
                      actionButton("Assign", "Assign Categories"),#
                      verbatimTextOutput("selectedRows"), ## doesn't seem to be working#
                      actionButton("Remove", "Finalize selections and remove not included"),#
                      helpText("Do not click 'finish' until all selections have been made. #
                               This button removes the unselected rows and generates a new table on the next page."),#
                      DT::dataTableOutput("gsm_table")#
             ),#
             # This will be where the CEL files are downloaded (confirmation, etc) ------------#
             tabPanel("Selection details", uiOutput("page4"), #
                      DT::dataTableOutput("finishedtable"),#
                      actionButton("downloadCEL","Download CEL files")#
             )#
  )#
)
shinyApp(ui,server)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
 ## Outputs#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
 # output$filteredgse <- DT::renderDataTable({#
 #     filtered_gse()[,c(1,2,7)]}, options=list(searching=TRUE, pageLength=20))#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
  output$GSEtoGSMlist <- renderTable(#
    if (input$GSE_GSM == 0)#
      return ()#
    else#
      return (filter(gse_gsm,gse %in% gse_to_keep()$gse)))#
  output$gsm_table <- DT::renderDataTable({#
    #if (input$Assign == 0)#
    #  return (gsm_annotated())#
    #else#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
#
  output$finishedtable <- renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectColumns(33)#
  })#
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
 ## Outputs#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
 # output$filteredgse <- DT::renderDataTable({#
 #     filtered_gse()[,c(1,2,7)]}, options=list(searching=TRUE, pageLength=20))#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
  output$GSEtoGSMlist <- renderTable(#
    if (input$GSE_GSM == 0)#
      return ()#
    else#
      return (filter(gse_gsm,gse %in% gse_to_keep()$gse)))#
  output$gsm_table <- DT::renderDataTable({#
    #if (input$Assign == 0)#
    #  return (gsm_annotated())#
    #else#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
#
  output$finishedtable <- renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  # observeEvent(input$downloadCEL, {#
  #     proxy.finishedtable %>% selectColumns(33)#
  # })#
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
 ## Outputs#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
 # output$filteredgse <- DT::renderDataTable({#
 #     filtered_gse()[,c(1,2,7)]}, options=list(searching=TRUE, pageLength=20))#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
  output$GSEtoGSMlist <- renderTable(#
    if (input$GSE_GSM == 0)#
      return ()#
    else#
      return (filter(gse_gsm,gse %in% gse_to_keep()$gse)))#
  output$gsm_table <- DT::renderDataTable({#
    #if (input$Assign == 0)#
    #  return (gsm_annotated())#
    #else#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectColumns(33)#
  })#
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
 ## Outputs#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
 # output$filteredgse <- DT::renderDataTable({#
 #     filtered_gse()[,c(1,2,7)]}, options=list(searching=TRUE, pageLength=20))#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
  output$GSEtoGSMlist <- renderTable(#
    if (input$GSE_GSM == 0)#
      return ()#
    else#
      return (filter(gse_gsm,gse %in% gse_to_keep()$gse)))#
  output$gsm_table <- DT::renderDataTable({#
    #if (input$Assign == 0)#
    #  return (gsm_annotated())#
    #else#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectColumns(7)#
  })#
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
 ## Outputs#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
 # output$filteredgse <- DT::renderDataTable({#
 #     filtered_gse()[,c(1,2,7)]}, options=list(searching=TRUE, pageLength=20))#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
  output$GSEtoGSMlist <- renderTable(#
    if (input$GSE_GSM == 0)#
      return ()#
    else#
      return (filter(gse_gsm,gse %in% gse_to_keep()$gse)))#
  output$gsm_table <- DT::renderDataTable({#
    #if (input$Assign == 0)#
    #  return (gsm_annotated())#
    #else#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectColumns(2)#
  })#
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
 ## Outputs#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
 # output$filteredgse <- DT::renderDataTable({#
 #     filtered_gse()[,c(1,2,7)]}, options=list(searching=TRUE, pageLength=20))#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
  output$GSEtoGSMlist <- renderTable(#
    if (input$GSE_GSM == 0)#
      return ()#
    else#
      return (filter(gse_gsm,gse %in% gse_to_keep()$gse)))#
  output$gsm_table <- DT::renderDataTable({#
    #if (input$Assign == 0)#
    #  return (gsm_annotated())#
    #else#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2)#
  })#
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
 ## Outputs#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
 # output$filteredgse <- DT::renderDataTable({#
 #     filtered_gse()[,c(1,2,7)]}, options=list(searching=TRUE, pageLength=20))#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
  output$GSEtoGSMlist <- renderTable(#
    if (input$GSE_GSM == 0)#
      return ()#
    else#
      return (filter(gse_gsm,gse %in% gse_to_keep()$gse)))#
  output$gsm_table <- DT::renderDataTable({#
    #if (input$Assign == 0)#
    #  return (gsm_annotated())#
    #else#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns('gsm')#
  })#
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
 ## Outputs#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
 # output$filteredgse <- DT::renderDataTable({#
 #     filtered_gse()[,c(1,2,7)]}, options=list(searching=TRUE, pageLength=20))#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
  output$GSEtoGSMlist <- renderTable(#
    if (input$GSE_GSM == 0)#
      return ()#
    else#
      return (filter(gse_gsm,gse %in% gse_to_keep()$gse)))#
  output$gsm_table <- DT::renderDataTable({#
    #if (input$Assign == 0)#
    #  return (gsm_annotated())#
    #else#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
 ## Outputs#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
 # output$filteredgse <- DT::renderDataTable({#
 #     filtered_gse()[,c(1,2,7)]}, options=list(searching=TRUE, pageLength=20))#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
  output$GSEtoGSMlist <- renderTable(#
    if (input$GSE_GSM == 0)#
      return ()#
    else#
      return (filter(gse_gsm,gse %in% gse_to_keep()$gse)))#
  output$gsm_table <- DT::renderDataTable({#
    #if (input$Assign == 0)#
    #  return (gsm_annotated())#
    #else#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
    #$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
      ## UI output, which kinda makes no sense now, but could be used to populate the categories with search terms#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=20, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM#
  gsm_annotated <- eventReactive(input$getGSM, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#
  output$gsm_table <- DT::renderDataTable({#
#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
    ## UI output, which kinda makes no sense now, but could be used to populate the categories with search terms#
#
  output$categorySelect <- renderUI(#
    fluidRow(#
      column(3,#
             selectInput("selection", "Select a Category",#
                         c("category1" <- {input$cat1},#
                           "category2" <- {input$cat2},#
                           "category3" <- {input$cat3},#
                           "category4" <- "Not included"))#
      )#
    )#
  )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#
  output$gsm_table <- DT::renderDataTable({#
#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
if(input$Assign ==0){#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
} else {#
    return(gsm_selected)#
}#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
if(input$Assign ==0){#
      return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
} else {#
    return(gsm_selected)#
}#
})#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  # Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
     if(input$Assign!=0){ return (gsm_annotated())}, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))}#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      if(input$Assign==0){#
          return (gsm_annotated())#
      } else {#
          return (rows$df)#
      }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
         if (input$Assign == 1) {#
           gsm_selected <- gsm_annotated()#
           gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
           rows$df <- gsm_selected#
           gsm_selected <<- rows$df # '<<-' is necessary to get this to the enclosing environment#
         }#
         else#
         {#
           gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
            gsm_selected <<- rows$df#
          }#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  if(input$getGSM !=0){#
      gsm_selected <- gsm_annotated()#
      gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
      gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
      rows$df <- gsm_selected#
  }#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
            gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
          }#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  if(input$getGSM !=0){#
      gsm_selected <- gsm_annotated()#
      gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
      gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
      rows$df <- gsm_selected#
  }#
  # gsm_selected <- eventReactive(input$Assign, {#
  #     gsm_annotated()$category <- rep("Not yet assigned", nrow(gsm_annotated()))#
  # })#
     observeEvent(input$Assign, {#
            gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  reactive(#
  if(input$getGSM !=0){#
      gsm_selected <- gsm_annotated()#
      gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
      gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
      rows$df <- gsm_selected#
  })#
      observeEvent(input$Assign, {#
            gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  reactive(#
      gsm_selected <- gsm_annotated()#
      gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
      gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
      rows$df <- gsm_selected#
      )#
      observeEvent(input$Assign, {#
            gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  reactive({#
      gsm_selected <- gsm_annotated()#
      gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
      gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
      rows$df <- gsm_selected#
  })#
      observeEvent(input$Assign, {#
            gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
gsm_selected
gsm_selected<-NULL
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  reactive({#
      gsm_selected <- gsm_annotated() #reactive to gsm_annotated being updated#
      gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
      rows$df <- gsm_selected#
  })#
      observeEvent(input$Assign, {#
            gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
gsm_selected
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- gsm_annotated() #reactive to gsm_annotated being updated#
  rows$df$category <- rep("Not yet assigned", nrow(gsm_selected))#
      observeEvent(input$Assign, {#
            gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  gsm_selected <- NULL#
  reactive({#
      gsm_selected <- gsm_annotated() #reactive to gsm_annotated being updated#
      gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
      rows$df <- gsm_selected#
  })#
      observeEvent(input$Assign, {#
            gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <- gsm_selected#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  gsm_selected <- NULL#
  reactive({#
      gsm_selected <- gsm_annotated() #reactive to gsm_annotated being updated#
      gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
      rows$df <<- gsm_selected#
  })#
      observeEvent(input$Assign, {#
            gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <<- gsm_selected#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame(gsm_annotated())#
  gsm_selected <- NULL#
  reactive({#
      gsm_selected <- gsm_annotated() #reactive to gsm_annotated being updated#
      gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
      rows$df <<- gsm_selected#
  })#
      observeEvent(input$Assign, {#
            gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
            rows$df <<- gsm_selected#
      })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
## SERVER#
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  observeEvent(input$getGSM,{#
      rows$df <<- gsm_annotated() #reactive to gsm_annotated being updated#
      rows$df$category <<- rep("Not yet assigned", nrow(gsm_selected))#
  })#
  observeEvent(input$Assign, {#
      rows$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
  observeEvent(input$getGSM,{#
      rows$df <<- isolate(gsm_annotated()) #reactive to gsm_annotated being updated#
      rows$df$category <<- rep("Not yet assigned", nrow(gsm_selected))#
  })#
  observeEvent(input$Assign, {#
      rows$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
      # if(input$Assign==0){#
      #     return (gsm_annotated())#
      # } else {#
          return (rows$df)#
      # }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  rows <- reactiveValues()#
  rows$df <- data.frame()#
 reactive({#
     rows$df <<- gsm_annotated()#
 })#
  #     rows$df$category <<- rep("Not yet assigned", nrow(gsm_selected))#
  # })#
  ##
  # observeEvent(input$Assign, {#
  #     rows$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
  # })#
  ##
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
rows
rows$df
rows$df<_NULL
rows$df<-NULL
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
           return (gsm_annotated())#
       } else {#
          return (samples$df)#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
 reactive({#
     samples$df <- gsm_annotated()#
 })#
  #     rows$df$category <<- rep("Not yet assigned", nrow(gsm_selected))#
  # })#
  ##
  # observeEvent(input$Assign, {#
  #     rows$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
  # })#
  ##
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
?dplyr
?dplyr::filter
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated())#
       } else {#
          return (samples$df)#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }      #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
## SERVER#
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated())#
       } else {#
          return (samples$df)#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
  })      #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
#$#$#$#$#$#$    Shiny App  $#$#$#$#$#$#$#
#########################################
#
## SERVER#
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated())#
       } else {#
          return (samples$df)#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(rows$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
#########################################
#
## SERVER#
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated())#
       } else {#
          return (samples$df)#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated())#
       } else {#
          return (samples$df)#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
      replaceData(proxy.gsm)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2) # selectColumn doesn't work. Instead what I would prefer is a PDF of the final table and a R list of CEL files to download#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated()[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       } else {#
          return (samples$df[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2) # selectColumn doesn't work. Instead what I would prefer is a PDF of the final table and a R list of CEL files to download#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
shinyApp(ui,server)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
server <- function(input, output, session) {#
      CELtoDownload<-NULL#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated()[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       } else {#
          return (samples$df[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2) # selectColumn doesn't work. Instead what I would prefer is a PDF of the final table and a R list of CEL files to download#
      CELtoDownload<<-proxy.finishedtable$gsm#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
CELtoDownload
saveData <- function(data) {#
  data <- as.data.frame(t(data))#
  if (exists("responses")) {#
    responses <<- rbind(responses, data)#
  } else {#
    responses <<- data#
  }#
}#
#
loadData <- function() {#
  if (exists("responses")) {#
    responses#
  }#
}
fields <- c("name", "used_shiny", "r_num_years")#
#
# Shiny app with 3 fields that the user can submit data for#
shinyApp(#
  ui = fluidPage(#
    DT::dataTableOutput("responses", width = 300), tags$hr(),#
    textInput("name", "Name", ""),#
    checkboxInput("used_shiny", "I've built a Shiny app in R before", FALSE),#
    sliderInput("r_num_years", "Number of years using R",#
                0, 25, 2, ticks = FALSE),#
    actionButton("submit", "Submit")#
  ),#
  server = function(input, output, session) {#
    # Whenever a field is filled, aggregate all form data#
    formData <- reactive({#
      data <- sapply(fields, function(x) input[[x]])#
      data#
    })#
    # When the Submit button is clicked, save the form data#
    observeEvent(input$submit, {#
      saveData(formData())#
    })#
    # Show the previous responses#
    # (update with current response when Submit is clicked)#
    output$responses <- DT::renderDataTable({#
      input$submit#
      loadData()#
    })     #
  }#
)
fields <- c("name", "used_shiny", "r_num_years")#
#
# Shiny app with 3 fields that the user can submit data for#
shinyApp(#
  ui = fluidPage(#
    DT::dataTableOutput("responses", width = 300), tags$hr(),#
    textInput("name", "Name", ""),#
    checkboxInput("used_shiny", "I've built a Shiny app in R before", FALSE),#
    sliderInput("r_num_years", "Number of years using R",#
                0, 25, 2, ticks = FALSE),#
    actionButton("submit", "Submit")#
  ),#
  server = function(input, output, session) {#
    # Whenever a field is filled, aggregate all form data#
    formData <- reactive({#
      data <- sapply(fields, function(x) input[[x]])#
      data#
    })#
    # When the Submit button is clicked, save the form data#
    observeEvent(input$submit, {#
      saveData(formData())#
    })#
    # Show the previous responses#
    # (update with current response when Submit is clicked)#
    output$responses <- DT::renderDataTable({#
      input$submit#
      loadData()#
    })     #
  }#
)
CELtoDownload <- c("gsm", "category", "timestamp")
CELt
CELtoDownload
?sapply
shinyApp(ui,server)
CELtoDownload <- c("gsm", "category", "timestamp")#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
#########################################
#$#$#$#$#$#$    Shiny App  $#$#$#$#$#$#$#
#########################################
#
## SERVER#
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated()[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       } else {#
          return (samples$df[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2) # selectColumn doesn't work. Instead what I would prefer is a PDF of the final table and a R list of CEL files to download#
      saveData(formData())#
  })#
  formData <- eventReactive(input$Remove, {#
      CELdl <- c(finishedtable()[,3],finishedtable()[,33],rep(Sys.time,nrow(finishedtable())))#
      CELdl#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
CELtoDownload
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated()[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       } else {#
          return (samples$df[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2) # selectColumn doesn't work. Instead what I would prefer is a PDF of the final table and a R list of CEL files to download#
#saveData(formData())#
  })#
  formData <- eventReactive(input$Remove, {#
      CELdl <- c(finishedtable()[,3],finishedtable()[,33],rep(Sys.time,nrow(finishedtable())))#
      CELdl#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
stamp<-Sys.time
stamp
as.text(stamp)
Sys.time
?Sys.time
Sys.time()
stamp<-Sys.time()
class(Stamp)
class(stamp)
as.text(stamp)
str(stamp)
Sys.Date()
stamp<-Sys.Date()
stamp
class(stamp)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated()[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       } else {#
          return (samples$df[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2) # selectColumn doesn't work. Instead what I would prefer is a PDF of the final table and a R list of CEL files to download#
#saveData(formData())#
  })#
  formData <- eventReactive(input$Remove, {#
      time <-Sys.time()#
      CELdl <- c(finishedtable()[,3],finishedtable()[,33],rep(time,nrow(finishedtable())))#
      CELdl#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated()[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       } else {#
          return (samples$df[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2) # selectColumn doesn't work. Instead what I would prefer is a PDF of the final table and a R list of CEL files to download#
saveData(formData())#
  })#
  formData <- eventReactive(input$Remove, {#
      time <-Sys.time()#
      CELdl <- c(finishedtable()[,3],finishedtable()[,33],rep(time,nrow(finishedtable())))#
      CELdl#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
ui <- fluidPage(#
  tags$head(tags$script(HTML(jscode))),#
#
  navbarPage("receptoR",#
              theme = "sandstone.css",#
    # Search for GSE  ------------------------------------------------------------------------------              #
            tabPanel("Select GEO data series (GSE)",  #search GSE, and select which to include#
                sidebarLayout(#
                    sidebarPanel(#
                        # Search for datasets ------------------------------------------------------#
                        h4("1. Search for GEO data series (GSE)"),#
                        radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
                        tagAppendAttributes(#
                            textInput("Key", "Enter search terms, separated by commas", value = ""),#
                            `data-proxy-click` = "Search"#
                        ),#
                        actionButton("Search", "Search"),#
                        hr(),#
                        # Define categories --------------------------------------------------------#
                        h4("3. Define the categories that you wish to assign each sample (GSM) for comparison."),#
                        textInput("cat1", "Define Category 1"),#
                        textInput("cat2", "Define Category 2"),#
                        textInput("cat3", "Define Category 3")#
                    ),#
                    # Filtered GSE list -----------------------------------------------------------#
                    mainPanel(#
                        h4("2. Highlight the desired search results (GSE) and click 'Retrieve GSM' to proceed"),#
                        actionButton("getGSM", "Retrieve GSM"),#
                        helpText("Do not click 'finish' until all selections have been made. This button removes the unselected rows and generates a new table on the next page."),#
                        DT::dataTableOutput("filteredgse")#
                    )#
                )#
            ),#
            # Assign samples to categories ------------------------------------------------------#
              tabPanel("Assign samples (GSM) to categories", #
                      h4("4. Highlight the desired search results and click 'assign' to assign them to the specificed category"),#
                      uiOutput("categorySelect"),#
                      actionButton("Assign", "Assign Categories"),#
                      actionButton("Remove", "Finalize selections and remove not included"),#
                      # ^ why aren't these two the same button?#
                      helpText("Do not click 'finish' until all selections have been made. #
                               This button removes the unselected rows and generates a new table on the next page."),#
                      DT::dataTableOutput("gsm_table")#
             ),#
             # This will be where the CEL files are downloaded (confirmation, etc) ------------#
             tabPanel("Selection details", uiOutput("page4"), #
                      DT::dataTableOutput("finishedtable"),#
                      actionButton("downloadCEL","Download CEL files"),#
                      tableOutput(CELdl)#
             )#
  )#
)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR')
ui <- fluidPage(#
  tags$head(tags$script(HTML(jscode))),#
#
  navbarPage("receptoR",#
              theme = "sandstone.css",#
    # Search for GSE  ------------------------------------------------------------------------------              #
            tabPanel("Select GEO data series (GSE)",  #search GSE, and select which to include#
                sidebarLayout(#
                    sidebarPanel(#
                        # Search for datasets ------------------------------------------------------#
                        h4("1. Search for GEO data series (GSE)"),#
                        radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
                        tagAppendAttributes(#
                            textInput("Key", "Enter search terms, separated by commas", value = ""),#
                            `data-proxy-click` = "Search"#
                        ),#
                        actionButton("Search", "Search"),#
                        hr(),#
                        # Define categories --------------------------------------------------------#
                        h4("3. Define the categories that you wish to assign each sample (GSM) for comparison."),#
                        textInput("cat1", "Define Category 1"),#
                        textInput("cat2", "Define Category 2"),#
                        textInput("cat3", "Define Category 3")#
                    ),#
                    # Filtered GSE list -----------------------------------------------------------#
                    mainPanel(#
                        h4("2. Highlight the desired search results (GSE) and click 'Retrieve GSM' to proceed"),#
                        actionButton("getGSM", "Retrieve GSM"),#
                        helpText("Do not click 'finish' until all selections have been made. This button removes the unselected rows and generates a new table on the next page."),#
                        DT::dataTableOutput("filteredgse")#
                    )#
                )#
            ),#
            # Assign samples to categories ------------------------------------------------------#
              tabPanel("Assign samples (GSM) to categories", #
                      h4("4. Highlight the desired search results and click 'assign' to assign them to the specificed category"),#
                      uiOutput("categorySelect"),#
                      actionButton("Assign", "Assign Categories"),#
                      actionButton("Remove", "Finalize selections and remove not included"),#
                      # ^ why aren't these two the same button?#
                      helpText("Do not click 'finish' until all selections have been made. #
                               This button removes the unselected rows and generates a new table on the next page."),#
                      DT::dataTableOutput("gsm_table")#
             ),#
             # This will be where the CEL files are downloaded (confirmation, etc) ------------#
             tabPanel("Selection details", uiOutput("page4"), #
                      DT::dataTableOutput("finishedtable"),#
                      actionButton("downloadCEL","Download CEL files"),#
                      tableOutput("CELdl")#
             )#
  )#
)
server <- function(input, output, session) {#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Search functions#
  Totalchar <- eventReactive(input$Search, {nchar(input$Key)})#
  Commas <- eventReactive(input$Search, {which(strsplit(input$Key, "")[[1]]==",")})#
  Ncommas <- eventReactive(input$Search, {length(Commas())})#
  Commasstart <- eventReactive(input$Search, {Commas() + 1})#
  Commasend <- eventReactive(input$Search, {Commas() - 1})#
  Searchterms <- eventReactive(input$Search, {#
    substring(input$Key, c(1, Commasstart()), c(Commasend(), Totalchar()))#
  })#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          dplyr::filter(gseGPL570, str_detect(gseGPL570$title, Searchterms()))#
      } else {#
          dplyr::filter(gseGPL1261, str_detect(gseGPL1261$summary, Searchterms()))#
      }#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=6, columnDefs=list(list(#
              targets = c(8,9,12),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
  ## Collect samples to use (GSE - GSM)#
    # List of the GSM associated with the selected GSE#
  gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  # Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
  ## ^ these two things should be condensed, so that there is one action on the button click#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (gsm_annotated()[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       } else {#
          return (samples$df[,c(-5:-7,-11,-12,-14:-26,-28:-32)])#
       }#
  }, options=list(searching=FALSE, columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  })#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(3,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Remove, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({finishedtable()[,c(2,3,4,10,31,32,33)]})#
  proxy.finishedtable = dataTableProxy('finishedtable')#
  observeEvent(input$downloadCEL, {#
      proxy.finishedtable %>% selectRows(2) %>% selectColumns(2) # selectColumn doesn't work. Instead what I would prefer is a PDF of the final table and a R list of CEL files to download#
#saveData(formData())#
  })#
  formData <- eventReactive(input$Remove, {#
      time <-Sys.time()#
      output$CELdl <- c(finishedtable()[,3],finishedtable()[,33],rep(time,nrow(finishedtable())))#
      output$CELdl#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
shinyApp(ui,server)
shinyApp(ui,server)
