pal4<-sample(pal3,14)
ggplot(fulldat,aes(x=array.exp,y=pcr.exp))+ geom_smooth(method="lm",colour="darkgrey") + geom_point(aes(colour=Symbol,shape=tissue),cex=4)+scale_y_reverse(limits=c(12,-6))+geom_errorbar(aes(ymin=pcr.min,ymax=pcr.max,colour=Symbol))+geom_errorbarh(aes(xmin=array.min,xmax=array.max,colour=Symbol))+xlab("norm. exp. (microarray)")+ylab("\u2206Ct (qPCR)") + theme_bw() + scale_colour_manual(name="gene symbol",values=pal4,labels=gNames) + annotate("text",label="\u03c1 = -0.38", x=11,y=11)+ coord_fixed(1/2)
pal$hex <-sample(pal$hex,14)
ggplot(fulldat,aes(x=array.exp,y=pcr.exp))+ geom_smooth(method="lm",colour="darkgrey") + geom_point(aes(colour=Symbol,shape=tissue),cex=4)+scale_y_reverse(limits=c(12,-6))+geom_errorbar(aes(ymin=pcr.min,ymax=pcr.max,colour=Symbol))+geom_errorbarh(aes(xmin=array.min,xmax=array.max,colour=Symbol))+xlab("norm. exp. (microarray)")+ylab("\u2206Ct (qPCR)") + theme_bw() + scale_colour_manual(name="gene symbol",values=pal$hex,labels=gNames) + annotate("text",label="\u03c1 = -0.38", x=11,y=11)+ coord_fixed(1/2)
pal$hex <-sample(pal$hex,14)
ggplot(fulldat,aes(x=array.exp,y=pcr.exp))+ geom_smooth(method="lm",colour="darkgrey") + geom_point(aes(colour=Symbol,shape=tissue),cex=4)+scale_y_reverse(limits=c(12,-6))+geom_errorbar(aes(ymin=pcr.min,ymax=pcr.max,colour=Symbol))+geom_errorbarh(aes(xmin=array.min,xmax=array.max,colour=Symbol))+xlab("norm. exp. (microarray)")+ylab("\u2206Ct (qPCR)") + theme_bw() + scale_colour_manual(name="gene symbol",values=pal$hex,labels=gNames) + annotate("text",label="\u03c1 = -0.38", x=11,y=11)+ coord_fixed(1/2)
pal$hex
print(pal$hex)
list(pal$hex)
expression(pal$hex)
pal
pal$hex
plot(pal)
library(rsm)
ccd.pick(2)
ccd(2)
ggplot(fulldat,aes(x=array.exp,y=pcr.exp))+ geom_smooth(method="lm",colour="darkgrey") + geom_point(aes(colour=Symbol,shape=tissue),cex=4)+scale_y_reverse(limits=c(12,-6))+geom_errorbar(aes(ymin=pcr.min,ymax=pcr.max,colour=Symbol))+geom_errorbarh(aes(xmin=array.min,xmax=array.max,colour=Symbol))+xlab("norm. exp. (microarray)")+ylab("\u2206Ct (qPCR)") + theme_bw() + scale_colour_discrete(name="gene symbol") + annotate("text",label="\u03c1 = -0.38", x=11,y=11)+ coord_fixed(1/2)
fulldat
q()
library(dplyr)#
library(tidyr)#
library(ggplot2)#
library(RColorBrewer)#
library(readr)#
library(stringr)#
library(shiny)#
library(shinythemes)#
library(shinyjs)#
library(dbplyr)#
library(DT)#
#
# Bioinformatics packages installed via biocLite:#
#source("https://bioconductor.org/biocLite.R")#
#biocLite(c('limma','annotate','genefilter','ComplexHeatmap','pheatmap','cowplot','GEOmetadb','mouse4302.db','hgu133plus2.db'))#
#biocLite(c('mixOmics','MergeMaid','GEOquery','inSilicoMerging','affy','sva','Rtsne','metaArray','testthat'))#
#
library(GEOmetadb)#
library(GEOquery)#
library(affy)#
#
library(limma)#
library(annotate)#
library(pheatmap)#
library(mixOmics)#
library(cowplot)#
#
library(pool)#
#
## 2018-12-02 not currently needed:#
    # library(genefilter)#
   #  library(ComplexHeatmap)#
   ##
   #  library(MergeMaid)#
   #  library(testthat)#
   #  library(metaArray)#
   #  library(Rtsne)#
   #  library(sva)#
#
# Microarray platform annotations:#
library(mouse4302.db) #
library(hgu133plus2.db)
source('~/Desktop/shiny-server/receptoR_final/functions.R')
load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/gseGPL570.rda")#
load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/gsmGPL570.rda")#
load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/gseGPL1261.rda")#
load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/gsmGPL1261.rda")#
load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-12_genelists.rda")
pool <- dbPool(#
  drv = RSQLite::SQLite(),#
  dbname = "/Volumes/ULTRA/across_array/GEOmetadb.sqlite"#
)
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gse <- eventReactive(input$Search, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(pool,sql,id1=input$Key)#
      filteredGSM<<-dbGetQuery(pool,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gse()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
## Collect samples to use (GSE - GSM)#
  ### List of the GSM associated with the selected GSE#
    gse_to_keep <- eventReactive(input$getGSM, {#
    filtered_gse()[input$filteredgse_rows_selected,]#
  })#
  ### Use GSE to load GSM from the prefiltered lists#
  gsm_annotated <- eventReactive(input$getGSM, {#
      withProgress(message='Collecting GSM',{#
      if(input$gplSelection=='human'){#
          dplyr::filter(gsmGPL570,series_id %in% gse_to_keep()$gse)#
      } else {#
          dplyr::filter(gsmGPL1261,series_id %in% gse_to_keep()$gse)#
      }#
      })#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
#
       if(input$Assign==0){#
          return (datatable(gsm_annotated()[,c(-5:-7,-11,-12,-14:-26,-28:-32)],options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))))#
       } else {#
          return (datatable(samples$df[,c(-5:-7,-11,-12,-14:-26,-28:-32)],options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      ))))%>% formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))))#
       }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable()[,c(2,3,4,10,31,32,33)],#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g<-function(){shinyApp(ui,server)}
jscode <- '#
$(function() {#
  var $els = $("[data-proxy-click]");#
  $.each(#
    $els,#
    function(idx, el) {#
      var $el = $(el);#
      var $proxy = $("#" + $el.data("proxyClick"));#
      $el.keydown(function (e) {#
        if (e.keyCode == 13) {#
          $proxy.click();#
        }#
      });#
    }#
  );#
});#
'#
#########################################
#$#$#$#$#$#$#$    UI     $#$#$#$#$#$#$#$#
#########################################
#
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSE  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("Key", "Enter search terms, separated by commas", value = ""),`data-proxy-click` = "Search"),#
           actionButton("Search", "Search"),#
           hr(),#
           HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Retrieve GSM\' to retrieve sample (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("getGSM", "Retrieve GSM")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("th-large",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("Assign", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               actionButton("downloadCEL","Download and Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO data series (\'GSE\') matching search query"), # return search here!#
            DT::dataTableOutput("filteredgse")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("From the selected series' (GSE) assign individual samples (GSM) to categories of your choosing."),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized."),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
g()
q()
library(dplyr)#
library(tidyr)#
library(ggplot2)#
library(RColorBrewer)#
library(readr)#
library(stringr)#
library(shiny)#
library(shinythemes)#
library(shinyjs)#
library(dbplyr)#
library(DT)
library(GEOmetadb)#
library(GEOquery)#
library(affy)#
#
library(limma)#
library(annotate)#
library(pheatmap)#
library(mixOmics)#
library(cowplot)#
#
library(pool)
library(mouse4302.db) #
library(hgu133plus2.db)
source('~/Desktop/shiny-server/receptoR_final/functions.R')
load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-12_genelists.rda")
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
       if(input$Assign==0){#
          return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      )))))#
       } else {#
          return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      ))))%>% formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))))#
       }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
jscode <- '#
$(function() {#
  var $els = $("[data-proxy-click]");#
  $.each(#
    $els,#
    function(idx, el) {#
      var $el = $(el);#
      var $proxy = $("#" + $el.data("proxyClick"));#
      $el.keydown(function (e) {#
        if (e.keyCode == 13) {#
          $proxy.click();#
        }#
      });#
    }#
  );#
});#
'
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("bong",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("Assign", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               actionButton("downloadCEL","Download and Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO data series (\'GSE\') matching search query"), # return search here!#
            DT::dataTableOutput("filteredgse")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("From the selected series' (GSE) assign individual samples (GSM) to categories of your choosing."),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized."),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
g<-function(){shinyApp(ui,server)}
g()
poolGEO <- dbPool(#
  drv = RSQLite::SQLite(),#
  dbname = "./../GEOmetadb.sqlite"#
)
poolGEO <- dbPool(#
  drv = RSQLite::SQLite(),#
  dbname = "/Volumes/ULTRA/across_array/GEOmetadb.sqlite"#
)
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  # catCol <- brewer.pal(3, "Set1")#
  # rowCol <-desat(catCol)#
  # # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  # userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
       if(input$Assign==0){#
          return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      )))))#
       } else {#
          return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      ))))%>% formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))))#
       }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
       if(input$Assign==0){#
          return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      )))))#
       } else {#
          return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      ))))%>% formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))))#
       }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
          return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      )))))%>% formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))))#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
          return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      )))))%>% formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3])))#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
          return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      )))))#
                # %>%formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3])))#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
          return (datatable(testTable,options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      )))))#
                # %>%formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3])))#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
testTable
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  # testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
          return (datatable(testTable,options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      )))))#
                # %>%formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3])))#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  # testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
          return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      )))))#
                # %>%formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3])))#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
          return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
              columnDefs=list(list(#
              targets = "_all",#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}")#
                      )))))#
                # %>%formatStyle('category',target="row",backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3])))#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  filtered_gsm <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      filteredGSM<<-dbGetQuery(poolGEO,query)#
      return(filteredGSM)#
  })#
#
  output$filteredgse <- DT::renderDataTable({#
          filtered_gsm()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL ## I think there is a problem here... without the "Assign" table, this isn't updated.#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,filtered_gsm()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
refresh
g()
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("bong",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("Assign", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               actionButton("downloadCEL","Download and Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO data series (\'GSE\') matching search query"), # return search here!#
            DT::dataTableOutput("searchGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("From the selected series' (GSE) assign individual samples (GSM) to categories of your choosing."),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized."),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$filteredgse_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchGSM_rows_selected,])#
      return(testTable)#
  })#
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  ##### This was an attempt to fix testTable. I think it's close, but still not updating correctly...#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  outputOptions(output, "searchGSM", suspendWhenHidden = FALSE)#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  outputOptions(output, "searchGSM", suspendWhenHidden = FALSE)#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  outputOptions(output, "searchGSM", suspendWhenHidden = FALSE)#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("bong",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("Assign", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               actionButton("downloadCEL","Download and Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO data series (\'GSE\') matching search query"), # return search here!#
            DT::dataTableOutput("searchResultGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("From the selected series' (GSE) assign individual samples (GSM) to categories of your choosing."),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized."),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
g()
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("bong",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("Assign", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               actionButton("downloadCEL","Download and Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO data series (\'GSE\') matching search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("From the selected series' (GSE) assign individual samples (GSM) to categories of your choosing."),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized."),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  observeEvent(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  observeEvent(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(testTable,options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
                    columnDefs=list(list(#
                    targets = "_all",#
                    render = JS(#
                        "function(data, type, row, meta) {",#
                            "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                            "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                            "}")#
                            )))))#
      # if(input$Assign==0){#
      #    return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
      #        columnDefs=list(list(#
      #        targets = "_all",#
      #        render = JS(#
      #            "function(data, type, row, meta) {",#
      #                "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
      #                "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
      #                "}")#
      #                )))))#
      # } else {#
      #    return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
      #        columnDefs=list(list(#
      #        targets = "_all",#
      #        render = JS(#
      #            "function(data, type, row, meta) {",#
      #                "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
      #                "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
      #                "}")#
      #                )))) %>%#
      #                formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      # }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 0) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.search = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.search %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  # proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      # proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("bong",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. PLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               actionButton("downloadCEL","Download and Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
closePool(poolGeo)
poolClose(poolGeo)
poolClose(poolGEO)
aaa<-read.csv("~/Documents/Retina/Abdullah/2019-03-29 gene expression correlation data aim 1 and aim 2.2.csv")#
aaa %>% group_by(aim) -> aaa#
#
aaa %>% filter(aim==1) %>% pull(ES.mean) -> x#
aaa %>% filter(aim==1) %>% pull(ARPE19.mean) -> y#
cor.test(x,y)
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation")#
ggsave("Aim1.pdf")
aa
aaa
aaa<-aaa[,1:5]
aaa
aaa$ES.min=aaa$ES.mean-aaa$ES.sd#
aaa$ES.max=aaa$ES.mean+aaa$ES.sd#
aaa$ARPE19.min=aaa$ARPE19.mean-aaa$ARPE19.s#
aaa$ARPE19.max=aaa$ARPE19.mean+aaa$ARPE19.s
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation")
aaa%>%filter(aim==2.2)
aaa<-read.csv("~/Documents/Retina/Abdullah/2019-03-29 gene expression correlation data aim 1 and aim 2.2.csv")#
aaa<-aaa[,1:6]
aaa %>% group_by(aim) -> aaa
aaa$ES.min=aaa$ES.mean-aaa$ES.sd#
aaa$ES.max=aaa$ES.mean+aaa$ES.sd#
aaa$ARPE19.min=aaa$ARPE19.mean-aaa$ARPE19.s#
aaa$ARPE19.max=aaa$ARPE19.mean+aaa$ARPE19.s
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation")#
ggsave("Aim1.pdf")
aaa$ES.min.log<-log(aaa$ES.min,base=2)
aaa
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") + scale_x_continuous(trans="log2")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") + scale_x_continuous(trans="log2") + scale_y_continuous(trans="log2")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") + scale_x_continuous(trans="log2") + scale_y_continuous(trans="log2")
library(qualpalr)
pal <- qualpal(n = 21, list(h = c(0, 240), s = c(0.4, 0.6), l = c(0.35, 0.65)))
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") + scale_x_continuous(trans="log2") + scale_y_continuous(trans="log2")+scale_colour_manual(name="gene symbol",values=pal$hex)
pal <- qualpal(n = 21, list(h = c(0, 240), s = c(0.2, 0.6), l = c(0.35, 0.65)))
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)
pal <- qualpal(n = 21, list(h = c(0, 240), s = c(0.5, 0.8), l = c(0.35, 0.65)))
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(breaks=c(0,1,2,3,4,5,10,20,,25))
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(breaks=c(0,1,2,3,4,5,10,20,25))
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log")+scale_y_continuous(trans="log")
ggsave("Desktop/aim1-correlation-log.pdf")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)
ggsave("Desktop/aim1-correlation-lin.pdf")
pal2 <- qualpal(n = 21, list(h = c(180,360), s = c(0.2, 0.8), l = c(0.35, 0.65)))
ggplot(aaa%>%filter(aim==2.2),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)
ggplot(aaa%>%filter(aim==2.2),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal2$hex)
ggplot(aaa%>%filter(aim==2.2),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.70\nP = 0.001", x=40,y=12.5)+ggtitle("Aim 2.2, Gene Correlation) +scale_colour_manual(name="gene symbol",values=pal2$hex)
ggplot(aaa%>%filter(aim==2.2),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.70\nP = 0.001", x=40,y=12.5)+ggtitle("Aim 2.2, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal2$hex)
ggsave("Desktop/aim2-2-correlation-lin.pdf")
?scale_x_continuous
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log")+scale_y_continuous(trans="logit")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log")+scale_y_continuous(trans="log1p)
""
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log")+scale_y_continuous(trans="log1p")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log1p")+scale_y_continuous(trans="log1p")
??log1p
ggsave("Desktop/aim1-correlation-log.pdf")
head(aaa)
aaa%>%filter(gene=="IGF-1")
g()
poolGEO <- dbPool(#
  drv = RSQLite::SQLite(),#
  dbname = "/Volumes/ULTRA/across_array/GEOmetadb.sqlite"#
)
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"),#
                             options = list(create=TRUE))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"),#
                             options = list(create=TRUE))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"),#
                             options = list(create=TRUE, plugins = "remove_button"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"),#
                             options = list(create=TRUE, plugins = list("remove_button")))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
install.packages(htmltools)
install.packages("htmltools")
library(htmltools)
addUIDep <- function(x) {#
  jqueryUIDep <- htmlDependency("jqueryui", "1.10.4", c(href="shared/jqueryui/1.10.4"),#
                                script = "jquery-ui.min.js",#
                                stylesheet = "jquery-ui.min.css")#
  attachDependencies(x, c(htmlDependencies(x), list(jqueryUIDep)))#
}#
#
shinyApp(#
  ui = fluidPage(#
    addUIDep(selectizeInput("variables", "", letters, c("a","b","c"), TRUE, #
                            options = list(plugins = list("drag_drop", "remove_button")))),#
    textOutput("variables")#
  ), #
  server = function(input, output) {#
    output$variables <- renderText(input$variables)#
  }#
)
poolCloe(poolGEO)
s(poolGEO)
poolClose(poolGEO)
q
q()
plate<-read.csv('Documents/Design of Experiments/Hepatocyte organoid ADR/DOE/Round 4/2019-06-10 DSD30.csv',sep=",")#
#
# load libraries#
library(dplyr)#
library(ggplot2)
library(ggplot2bdc)
platemap<-mutate(plate,row=as.numeric(match(toupper(substr(well,1,1)), LETTERS)),col=as.numeric(substr(well,2,5)))
today<-strftime(Sys.time(),"%Y-%m-%d")
platemap
ggplot(data=platemap,aes(x=col,y=row))+geom_point(data=expand.grid(seq(1, 12), seq(1, 8)), aes(x=Var1, y=Var2),color="grey90", fill="white", shape=21, size=20)+geom_point(aes(colour=as.factor(DMSO)),size=20)+scale_y_reverse(breaks=seq(1, 8), labels=LETTERS[1:8],limits=c(8.3,0.7))+scale_x_continuous(breaks=seq(1, 12),limits=c(0.7,12.3))+labs(title=paste("Hepatocyte organoids DSD30",today,sep=" "),colour="DMSO")+ scale_colour_discrete(labels=c("0","6","12")) +theme_bdc_microtiter()
ggplot(data=platemap,aes(x=col,y=row))+geom_point(data=expand.grid(seq(1, 12), seq(1, 8)), aes(x=Var1, y=Var2),color="grey90", fill="white", shape=21, size=20)+geom_point(aes(colour=as.factor(DMSO)),size=10)+scale_y_reverse(breaks=seq(1, 8), labels=LETTERS[1:8],limits=c(8.3,0.7))+scale_x_continuous(breaks=seq(1, 12),limits=c(0.7,12.3))+labs(title=paste("Hepatocyte organoids DSD30",today,sep=" "),colour="DMSO")+ scale_colour_discrete(labels=c("0","6","12")) +theme_bdc_microtiter()
ggsave('Documents/Design of Experiments/Hepatocyte organoid ADR/DOE/Round 4/2019-06-10_platemap_DMSO.pdf')
ggplot(data=platemap,aes(x=col,y=row))+geom_point(data=expand.grid(seq(1, 12), seq(1, 8)), aes(x=Var1, y=Var2),color="grey90", fill="white", shape=21, size=20)+geom_point(aes(colour=as.factor(DMSO)),size=10)+scale_y_reverse(breaks=seq(1, 8), labels=LETTERS[1:8],limits=c(8.3,0.7))+scale_x_continuous(breaks=seq(1, 12),limits=c(0.7,12.3))+labs(title=paste("Hepatocyte organoids DSD30",today,sep=" "),colour="DMSO")+ scale_colour_discrete(labels=c("0","12","24")) +theme_bdc_microtiter()
ggsave('Documents/Design of Experiments/Hepatocyte organoid ADR/DOE/Round 4/2019-06-10_platemap_DMSO.pdf')
ggplot(data=platemap,aes(x=col,y=row))+geom_point(data=expand.grid(seq(1, 12), seq(1, 8)), aes(x=Var1, y=Var2),color="grey90", fill="white", shape=21, size=20)+geom_point(aes(colour=as.factor(tryptose.phosphate.broth)),size=10)+scale_y_reverse(breaks=seq(1, 8), labels=LETTERS[1:8],limits=c(8.3,0.7))+scale_x_continuous(breaks=seq(1, 12),limits=c(0.7,12.3))+labs(title=paste("Hepatocyte organoids DSD30",today,sep=" "),colour="Tryptose phosphate broth")+ scale_colour_discrete(labels=c("0","12","24")) +theme_bdc_microtiter()
ggsave('Documents/Design of Experiments/Hepatocyte organoid ADR/DOE/Round 4/2019-06-10_platemap_Tryptose broth.pdf')
q()
library(ggplot2bdc)#
library(ggplot2)#
library(dplyr)#
library(grDevices)#
library(RColorBrewer)
morph<-read.csv("~/Dropbox/Hepatocyte organoids/2019-04-11 Round 2_DSD28-morphology.csv")#
platemap<-mutate(morph,row=as.numeric(match(toupper(substr(well,1,1)), LETTERS)),col=as.numeric(substr(well,2,5)))#
ggplot(data=platemap,aes(x=col,y=row))+geom_point(aes(colour=score),size=24,shape=15)+scale_y_reverse(breaks=seq(1, 8), labels=LETTERS[1:8],limits=c(8.3,0.7))+scale_x_continuous(breaks=seq(1, 12),limits=c(0.7,12.3))+labs(title="Hepatic organoid morphology score (d19 100-cell aggregates, high activin, 2D, pHEMA)",colour="morph.\nscore")+scale_colour_gradient(low=brewer.pal(5,"YlGnBu")[1],high=brewer.pal(5,"YlOrRd")[5])
ggplot(data=platemap,aes(x=col,y=row))+geom_point(aes(colour=score),size=24,shape=15)+scale_y_reverse(breaks=seq(1, 8), labels=LETTERS[1:8],limits=c(8.3,0.7))+scale_x_continuous(breaks=seq(1, 12),limits=c(0.7,12.3))+labs(title="Hepatic organoid morphology score (d19 100-cell aggregates, high activin, 2D, pHEMA)",colour="morph.\nscore")+scale_colour_gradient(low=brewer.pal(5,"YlGnBu")[1],high=brewer.pal(5,"YlGnBu")[5])
ggplot(data=platemap,aes(x=col,y=row))+geom_point(aes(colour=score),size=24,shape=15)+scale_y_reverse(breaks=seq(1, 8), labels=LETTERS[1:8],limits=c(8.3,0.7))+scale_x_continuous(breaks=seq(1, 12),limits=c(0.7,12.3))+labs(title="Hepatic organoid morphology score (d19 100-cell aggregates, high activin, 2D, pHEMA)",colour="morph.\nscore")+scale_colour_gradient(low=brewer.pal(5,"GnBu")[1],high=brewer.pal(5,"GnBu")[5])
ggplot(data=platemap,aes(x=col,y=row))+geom_point(aes(colour=score),size=24,shape=15)+scale_y_reverse(breaks=seq(1, 8), labels=LETTERS[1:8],limits=c(8.3,0.7))+scale_x_continuous(breaks=seq(1, 12),limits=c(0.7,12.3))+labs(title="Hepatic organoid morphology score (d19 100-cell aggregates, high activin, 2D, pHEMA)",colour="morph.\nscore")+scale_colour_gradient(low=brewer.pal(9,"GnBu")[3],high=brewer.pal(9,"GnBu")[9])
q()
library(rsm)
ccd(6)
q()
library(shiny)
library(shinyjs)
tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)"),#
           tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),
tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)"),#
           tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")))
tags$div(class="inputWithIcon",icon("circle",class="fa-2x"),textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)")
)
textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)")
textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)",style="test-indent:17px")
jscode <- '#
$(function() {#
  var $els = $("[data-proxy-click]");#
  $.each(#
    $els,#
    function(idx, el) {#
      var $el = $(el);#
      var $proxy = $("#" + $el.data("proxyClick"));#
      $el.keydown(function (e) {#
        if (e.keyCode == 13) {#
          $proxy.click();#
        }#
      });#
    }#
  );#
});#
'#
#########################################
#$#$#$#$#$#$#$    UI     $#$#$#$#$#$#$#$#
#########################################
#
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    id = "receptorMain",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       value ="startPanel",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolated RNA from this cell is converted to labeled cDNA, which is hybridized to an oligonucleotide probe array to measure expression."),tags$li("Each array represents a snapshot of a specific transcriptome. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our cells or tissues of interest to direct bioengineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by ",#
               actionLink("linkSearch","searching for expression data"),#
               " to design your own experiment, or by ",#
               actionLink("linkLoad","loading and analysing an existing experiment.")),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("code created by Derek Toms, Qing Yun Tong and Matthew Workentine"),#
               p("Copyright (C) 2019, code licensed under GPLv3")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Microarray Database",#
       value = "searchPanel",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching the Gene Expression Omnibus (GEO) database for publicly available transcriptome data. Depending on availability, these may be available for specific tissues or isolated cell types. In the next step, these samples will be assigned to one of three categories to determine differential expression between sample types."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           helpText("Search for multiple keywords using the boolean operators 'AND','OR','NOT', and the wildcard '*'. For example: 'liver AND hepa* NOT brain'."),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories. A minimum of two and a maximum of three categories should be defined. If you are only interested in a single sample type it is recommended that this is compared to a 'background' sample to identify enriched receptor genes."),#
#
           tags$div(class="inputWithIcon",icon("circle",class="fa-2x"),textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)"),#
           tags$span(style="color:#E41A1C",)),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2 (e.g., photoreceptors)"),#
           tags$span(style="color:#377EB8",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),#
           tags$span(style="color:#4DAF4A",icon("circle",class="fa-2x"))#
           ),#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. \nPLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               downloadButton("report","Download Report"),#
               actionButton("downloadCEL","Process")),#
           hr(),#
               # Help banner on the bottom -------------------------#
           # h4("Help me!"),#
           p("Click ",actionLink("linkReset","here "),"to start again.")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Expression Datasets",#
        value="expressionPanel",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            uiOutput("loadUserExperiments"),#
            hr(),#
            checkboxGroupInput("genelist", "Select a receptor type to analyze", #
                  choices = NULL),#
            br(),#
            selectInput("gene", "Select additional non-receptor coding gene(s) to include in the analysis.", choices = NULL, multiple = TRUE),#
            helpText("Search by gene symbol; availability of a given gene is based on microarray probe annotations."),#
            downloadButton("reportDEG","Download differential gene expression analysis"),#
            helpText("This Microsoft Excel file (.XSLX) contains all differentially expressed genes among these tissues. It can be further used for downstream analyses including functional enrichment analysis.")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-by-gene Expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            # tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-by-gene Expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Violin Plot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Gene-level Expression",#
        h3("Compare genes based on absolute expression and differential expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Gene expression"),#
            checkboxGroupInput("tissues", label = "Select tissues to include",#
            choices = NULL, selected = NULL),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            checkboxGroupInput("de", label = "Choose comparison(s) to show", choices = NULL, selected = NULL),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show gene symbols (row names)", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, h4("Cluster analysis and a heatmap representation of gene expression."), p("Genes with similar expression patterns will cluster as rows, while individual microarrays cluster as columns."), uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", h4("Boxplots of expression data by tissue."), plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", h4("Boxplots of expression data by gene."), plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Sample-level Expression",#
        h3("Compare trends in samples based on experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Sample expression"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = NULL, selected = NULL),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Principle component analysis", h4("Principle component analysis (PCA) to visualize relatedness among tissues."), p("Observations are orthogonally transformed and each component accounts for as much variability in the data as possible. The first two principle components for this genelist are graphed below."), plotOutput("indPlot", height = 800)),#
            tabPanel("Component loadings plot", h4("Gene contribution to each principle component."), p("The longer the bar (in either direction) the more that gene contributes to that component."), plotOutput("contribPlot", height = 800)),#
            tabPanel("Circle variance", h4("Circle variance projections onto tissue."), p("Strongly correlated genes are projected in the same direction from the origin; the greater the distance the stronger the association."), plotOutput("varPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
icon("circle",class="fa-2x",style="color:#E41A1C")
icon("circle",class="fa-2x",style="color:#E41A1C")tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")))
tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))
tags$div(class="inputWithIcon",#
           tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")),#
           textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)"))
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    id = "receptorMain",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       value ="startPanel",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolated RNA from this cell is converted to labeled cDNA, which is hybridized to an oligonucleotide probe array to measure expression."),tags$li("Each array represents a snapshot of a specific transcriptome. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our cells or tissues of interest to direct bioengineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by ",#
               actionLink("linkSearch","searching for expression data"),#
               " to design your own experiment, or by ",#
               actionLink("linkLoad","loading and analysing an existing experiment.")),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("code created by Derek Toms, Qing Yun Tong and Matthew Workentine"),#
               p("Copyright (C) 2019, code licensed under GPLv3")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Microarray Database",#
       value = "searchPanel",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching the Gene Expression Omnibus (GEO) database for publicly available transcriptome data. Depending on availability, these may be available for specific tissues or isolated cell types. In the next step, these samples will be assigned to one of three categories to determine differential expression between sample types."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           helpText("Search for multiple keywords using the boolean operators 'AND','OR','NOT', and the wildcard '*'. For example: 'liver AND hepa* NOT brain'."),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories. A minimum of two and a maximum of three categories should be defined. If you are only interested in a single sample type it is recommended that this is compared to a 'background' sample to identify enriched receptor genes."),#
#
           tags$div(class="inputWithIcon",#
           tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")),#
           textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)")),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2 (e.g., photoreceptors)"),#
           tags$span(style="color:#377EB8",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),#
           tags$span(style="color:#4DAF4A",icon("circle",class="fa-2x"))#
           ),#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. \nPLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               downloadButton("report","Download Report"),#
               actionButton("downloadCEL","Process")),#
           hr(),#
               # Help banner on the bottom -------------------------#
           # h4("Help me!"),#
           p("Click ",actionLink("linkReset","here "),"to start again.")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Expression Datasets",#
        value="expressionPanel",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            uiOutput("loadUserExperiments"),#
            hr(),#
            checkboxGroupInput("genelist", "Select a receptor type to analyze", #
                  choices = NULL),#
            br(),#
            selectInput("gene", "Select additional non-receptor coding gene(s) to include in the analysis.", choices = NULL, multiple = TRUE),#
            helpText("Search by gene symbol; availability of a given gene is based on microarray probe annotations."),#
            downloadButton("reportDEG","Download differential gene expression analysis"),#
            helpText("This Microsoft Excel file (.XSLX) contains all differentially expressed genes among these tissues. It can be further used for downstream analyses including functional enrichment analysis.")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-by-gene Expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            # tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-by-gene Expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Violin Plot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Gene-level Expression",#
        h3("Compare genes based on absolute expression and differential expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Gene expression"),#
            checkboxGroupInput("tissues", label = "Select tissues to include",#
            choices = NULL, selected = NULL),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            checkboxGroupInput("de", label = "Choose comparison(s) to show", choices = NULL, selected = NULL),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show gene symbols (row names)", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, h4("Cluster analysis and a heatmap representation of gene expression."), p("Genes with similar expression patterns will cluster as rows, while individual microarrays cluster as columns."), uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", h4("Boxplots of expression data by tissue."), plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", h4("Boxplots of expression data by gene."), plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Sample-level Expression",#
        h3("Compare trends in samples based on experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Sample expression"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = NULL, selected = NULL),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Principle component analysis", h4("Principle component analysis (PCA) to visualize relatedness among tissues."), p("Observations are orthogonally transformed and each component accounts for as much variability in the data as possible. The first two principle components for this genelist are graphed below."), plotOutput("indPlot", height = 800)),#
            tabPanel("Component loadings plot", h4("Gene contribution to each principle component."), p("The longer the bar (in either direction) the more that gene contributes to that component."), plotOutput("contribPlot", height = 800)),#
            tabPanel("Circle variance", h4("Circle variance projections onto tissue."), p("Strongly correlated genes are projected in the same direction from the origin; the greater the distance the stronger the association."), plotOutput("varPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
library(shinythemes)
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    id = "receptorMain",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       value ="startPanel",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolated RNA from this cell is converted to labeled cDNA, which is hybridized to an oligonucleotide probe array to measure expression."),tags$li("Each array represents a snapshot of a specific transcriptome. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our cells or tissues of interest to direct bioengineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by ",#
               actionLink("linkSearch","searching for expression data"),#
               " to design your own experiment, or by ",#
               actionLink("linkLoad","loading and analysing an existing experiment.")),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("code created by Derek Toms, Qing Yun Tong and Matthew Workentine"),#
               p("Copyright (C) 2019, code licensed under GPLv3")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Microarray Database",#
       value = "searchPanel",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching the Gene Expression Omnibus (GEO) database for publicly available transcriptome data. Depending on availability, these may be available for specific tissues or isolated cell types. In the next step, these samples will be assigned to one of three categories to determine differential expression between sample types."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           helpText("Search for multiple keywords using the boolean operators 'AND','OR','NOT', and the wildcard '*'. For example: 'liver AND hepa* NOT brain'."),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories. A minimum of two and a maximum of three categories should be defined. If you are only interested in a single sample type it is recommended that this is compared to a 'background' sample to identify enriched receptor genes."),#
#
           tags$div(class="inputWithIcon",#
           tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")),#
           textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)")),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2 (e.g., photoreceptors)"),#
           tags$span(style="color:#377EB8",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),#
           tags$span(style="color:#4DAF4A",icon("circle",class="fa-2x"))#
           ),#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. \nPLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               downloadButton("report","Download Report"),#
               actionButton("downloadCEL","Process")),#
           hr(),#
               # Help banner on the bottom -------------------------#
           # h4("Help me!"),#
           p("Click ",actionLink("linkReset","here "),"to start again.")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Expression Datasets",#
        value="expressionPanel",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            uiOutput("loadUserExperiments"),#
            hr(),#
            checkboxGroupInput("genelist", "Select a receptor type to analyze", #
                  choices = NULL),#
            br(),#
            selectInput("gene", "Select additional non-receptor coding gene(s) to include in the analysis.", choices = NULL, multiple = TRUE),#
            helpText("Search by gene symbol; availability of a given gene is based on microarray probe annotations."),#
            downloadButton("reportDEG","Download differential gene expression analysis"),#
            helpText("This Microsoft Excel file (.XSLX) contains all differentially expressed genes among these tissues. It can be further used for downstream analyses including functional enrichment analysis.")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-by-gene Expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            # tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-by-gene Expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Violin Plot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Gene-level Expression",#
        h3("Compare genes based on absolute expression and differential expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Gene expression"),#
            checkboxGroupInput("tissues", label = "Select tissues to include",#
            choices = NULL, selected = NULL),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            checkboxGroupInput("de", label = "Choose comparison(s) to show", choices = NULL, selected = NULL),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show gene symbols (row names)", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, h4("Cluster analysis and a heatmap representation of gene expression."), p("Genes with similar expression patterns will cluster as rows, while individual microarrays cluster as columns."), uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", h4("Boxplots of expression data by tissue."), plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", h4("Boxplots of expression data by gene."), plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Sample-level Expression",#
        h3("Compare trends in samples based on experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Sample expression"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = NULL, selected = NULL),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Principle component analysis", h4("Principle component analysis (PCA) to visualize relatedness among tissues."), p("Observations are orthogonally transformed and each component accounts for as much variability in the data as possible. The first two principle components for this genelist are graphed below."), plotOutput("indPlot", height = 800)),#
            tabPanel("Component loadings plot", h4("Gene contribution to each principle component."), p("The longer the bar (in either direction) the more that gene contributes to that component."), plotOutput("contribPlot", height = 800)),#
            tabPanel("Circle variance", h4("Circle variance projections onto tissue."), p("Strongly correlated genes are projected in the same direction from the origin; the greater the distance the stronger the association."), plotOutput("varPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
source('~/Desktop/shiny-server/receptoR_final/functions.R')
server <- function(input, output, session) {#
}
shinyApp(ui,server)
textInputAddon <- function (inputId, label, value = "", placeholder = NULL, addon, width = NULL)#
{#
  value <- shiny::restoreInput(id = inputId, default = value)#
  htmltools::tags$div(#
    class = "form-group shiny-input-container",#
    label %AND% htmltools::tags$label(label, `for` = inputId),#
    style = if (!is.null(width)) paste0("width: ", htmltools::validateCssUnit(width), ";"),#
    htmltools::tags$div(#
      style = "margin-bottom: 5px;", class="input-group",#
      addon %AND% htmltools::tags$span(class="input-group-addon", addon),#
      htmltools::tags$input(#
        id = inputId, type = "text", class = "form-control",#
        value = value, placeholder = placeholder#
      )#
    )#
  )#
}
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    id = "receptorMain",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       value ="startPanel",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolated RNA from this cell is converted to labeled cDNA, which is hybridized to an oligonucleotide probe array to measure expression."),tags$li("Each array represents a snapshot of a specific transcriptome. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our cells or tissues of interest to direct bioengineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by ",#
               actionLink("linkSearch","searching for expression data"),#
               " to design your own experiment, or by ",#
               actionLink("linkLoad","loading and analysing an existing experiment.")),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("code created by Derek Toms, Qing Yun Tong and Matthew Workentine"),#
               p("Copyright (C) 2019, code licensed under GPLv3")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Microarray Database",#
       value = "searchPanel",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching the Gene Expression Omnibus (GEO) database for publicly available transcriptome data. Depending on availability, these may be available for specific tissues or isolated cell types. In the next step, these samples will be assigned to one of three categories to determine differential expression between sample types."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           helpText("Search for multiple keywords using the boolean operators 'AND','OR','NOT', and the wildcard '*'. For example: 'liver AND hepa* NOT brain'."),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories. A minimum of two and a maximum of three categories should be defined. If you are only interested in a single sample type it is recommended that this is compared to a 'background' sample to identify enriched receptor genes."),#
#
           # tags$div(class="inputWithIcon",#
           # tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")),#
           # textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)")),#
#
           textInputAddon(inputId = "cat1", label = NULL, placeholder = "Category 1 (e.g., pancreatic endocrine cells)", addon = icon("circle")),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2 (e.g., photoreceptors)"),#
           tags$span(style="color:#377EB8",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),#
           tags$span(style="color:#4DAF4A",icon("circle",class="fa-2x"))#
           ),#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. \nPLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               downloadButton("report","Download Report"),#
               actionButton("downloadCEL","Process")),#
           hr(),#
               # Help banner on the bottom -------------------------#
           # h4("Help me!"),#
           p("Click ",actionLink("linkReset","here "),"to start again.")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Expression Datasets",#
        value="expressionPanel",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            uiOutput("loadUserExperiments"),#
            hr(),#
            checkboxGroupInput("genelist", "Select a receptor type to analyze", #
                  choices = NULL),#
            br(),#
            selectInput("gene", "Select additional non-receptor coding gene(s) to include in the analysis.", choices = NULL, multiple = TRUE),#
            helpText("Search by gene symbol; availability of a given gene is based on microarray probe annotations."),#
            downloadButton("reportDEG","Download differential gene expression analysis"),#
            helpText("This Microsoft Excel file (.XSLX) contains all differentially expressed genes among these tissues. It can be further used for downstream analyses including functional enrichment analysis.")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-by-gene Expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            # tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-by-gene Expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Violin Plot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Gene-level Expression",#
        h3("Compare genes based on absolute expression and differential expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Gene expression"),#
            checkboxGroupInput("tissues", label = "Select tissues to include",#
            choices = NULL, selected = NULL),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            checkboxGroupInput("de", label = "Choose comparison(s) to show", choices = NULL, selected = NULL),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show gene symbols (row names)", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, h4("Cluster analysis and a heatmap representation of gene expression."), p("Genes with similar expression patterns will cluster as rows, while individual microarrays cluster as columns."), uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", h4("Boxplots of expression data by tissue."), plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", h4("Boxplots of expression data by gene."), plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Sample-level Expression",#
        h3("Compare trends in samples based on experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Sample expression"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = NULL, selected = NULL),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Principle component analysis", h4("Principle component analysis (PCA) to visualize relatedness among tissues."), p("Observations are orthogonally transformed and each component accounts for as much variability in the data as possible. The first two principle components for this genelist are graphed below."), plotOutput("indPlot", height = 800)),#
            tabPanel("Component loadings plot", h4("Gene contribution to each principle component."), p("The longer the bar (in either direction) the more that gene contributes to that component."), plotOutput("contribPlot", height = 800)),#
            tabPanel("Circle variance", h4("Circle variance projections onto tissue."), p("Strongly correlated genes are projected in the same direction from the origin; the greater the distance the stronger the association."), plotOutput("varPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
library(magrittr)
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    id = "receptorMain",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       value ="startPanel",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolated RNA from this cell is converted to labeled cDNA, which is hybridized to an oligonucleotide probe array to measure expression."),tags$li("Each array represents a snapshot of a specific transcriptome. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our cells or tissues of interest to direct bioengineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by ",#
               actionLink("linkSearch","searching for expression data"),#
               " to design your own experiment, or by ",#
               actionLink("linkLoad","loading and analysing an existing experiment.")),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("code created by Derek Toms, Qing Yun Tong and Matthew Workentine"),#
               p("Copyright (C) 2019, code licensed under GPLv3")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Microarray Database",#
       value = "searchPanel",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching the Gene Expression Omnibus (GEO) database for publicly available transcriptome data. Depending on availability, these may be available for specific tissues or isolated cell types. In the next step, these samples will be assigned to one of three categories to determine differential expression between sample types."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           helpText("Search for multiple keywords using the boolean operators 'AND','OR','NOT', and the wildcard '*'. For example: 'liver AND hepa* NOT brain'."),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories. A minimum of two and a maximum of three categories should be defined. If you are only interested in a single sample type it is recommended that this is compared to a 'background' sample to identify enriched receptor genes."),#
#
           # tags$div(class="inputWithIcon",#
           # tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")),#
           # textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)")),#
#
           textInputAddon(inputId = "cat1", label = NULL, placeholder = "Category 1 (e.g., pancreatic endocrine cells)", addon = icon("circle")),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2 (e.g., photoreceptors)"),#
           tags$span(style="color:#377EB8",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),#
           tags$span(style="color:#4DAF4A",icon("circle",class="fa-2x"))#
           ),#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. \nPLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               downloadButton("report","Download Report"),#
               actionButton("downloadCEL","Process")),#
           hr(),#
               # Help banner on the bottom -------------------------#
           # h4("Help me!"),#
           p("Click ",actionLink("linkReset","here "),"to start again.")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Expression Datasets",#
        value="expressionPanel",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            uiOutput("loadUserExperiments"),#
            hr(),#
            checkboxGroupInput("genelist", "Select a receptor type to analyze", #
                  choices = NULL),#
            br(),#
            selectInput("gene", "Select additional non-receptor coding gene(s) to include in the analysis.", choices = NULL, multiple = TRUE),#
            helpText("Search by gene symbol; availability of a given gene is based on microarray probe annotations."),#
            downloadButton("reportDEG","Download differential gene expression analysis"),#
            helpText("This Microsoft Excel file (.XSLX) contains all differentially expressed genes among these tissues. It can be further used for downstream analyses including functional enrichment analysis.")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-by-gene Expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            # tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-by-gene Expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Violin Plot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Gene-level Expression",#
        h3("Compare genes based on absolute expression and differential expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Gene expression"),#
            checkboxGroupInput("tissues", label = "Select tissues to include",#
            choices = NULL, selected = NULL),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            checkboxGroupInput("de", label = "Choose comparison(s) to show", choices = NULL, selected = NULL),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show gene symbols (row names)", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, h4("Cluster analysis and a heatmap representation of gene expression."), p("Genes with similar expression patterns will cluster as rows, while individual microarrays cluster as columns."), uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", h4("Boxplots of expression data by tissue."), plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", h4("Boxplots of expression data by gene."), plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Sample-level Expression",#
        h3("Compare trends in samples based on experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Sample expression"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = NULL, selected = NULL),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Principle component analysis", h4("Principle component analysis (PCA) to visualize relatedness among tissues."), p("Observations are orthogonally transformed and each component accounts for as much variability in the data as possible. The first two principle components for this genelist are graphed below."), plotOutput("indPlot", height = 800)),#
            tabPanel("Component loadings plot", h4("Gene contribution to each principle component."), p("The longer the bar (in either direction) the more that gene contributes to that component."), plotOutput("contribPlot", height = 800)),#
            tabPanel("Circle variance", h4("Circle variance projections onto tissue."), p("Strongly correlated genes are projected in the same direction from the origin; the greater the distance the stronger the association."), plotOutput("varPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
library(htmltools)
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    id = "receptorMain",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       value ="startPanel",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolated RNA from this cell is converted to labeled cDNA, which is hybridized to an oligonucleotide probe array to measure expression."),tags$li("Each array represents a snapshot of a specific transcriptome. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our cells or tissues of interest to direct bioengineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by ",#
               actionLink("linkSearch","searching for expression data"),#
               " to design your own experiment, or by ",#
               actionLink("linkLoad","loading and analysing an existing experiment.")),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("code created by Derek Toms, Qing Yun Tong and Matthew Workentine"),#
               p("Copyright (C) 2019, code licensed under GPLv3")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Microarray Database",#
       value = "searchPanel",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching the Gene Expression Omnibus (GEO) database for publicly available transcriptome data. Depending on availability, these may be available for specific tissues or isolated cell types. In the next step, these samples will be assigned to one of three categories to determine differential expression between sample types."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           helpText("Search for multiple keywords using the boolean operators 'AND','OR','NOT', and the wildcard '*'. For example: 'liver AND hepa* NOT brain'."),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories. A minimum of two and a maximum of three categories should be defined. If you are only interested in a single sample type it is recommended that this is compared to a 'background' sample to identify enriched receptor genes."),#
#
           # tags$div(class="inputWithIcon",#
           # tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")),#
           # textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)")),#
#
           textInputAddon(inputId = "cat1", label = NULL, placeholder = "Category 1 (e.g., pancreatic endocrine cells)", addon = icon("circle")),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2 (e.g., photoreceptors)"),#
           tags$span(style="color:#377EB8",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),#
           tags$span(style="color:#4DAF4A",icon("circle",class="fa-2x"))#
           ),#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. \nPLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               downloadButton("report","Download Report"),#
               actionButton("downloadCEL","Process")),#
           hr(),#
               # Help banner on the bottom -------------------------#
           # h4("Help me!"),#
           p("Click ",actionLink("linkReset","here "),"to start again.")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Expression Datasets",#
        value="expressionPanel",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            uiOutput("loadUserExperiments"),#
            hr(),#
            checkboxGroupInput("genelist", "Select a receptor type to analyze", #
                  choices = NULL),#
            br(),#
            selectInput("gene", "Select additional non-receptor coding gene(s) to include in the analysis.", choices = NULL, multiple = TRUE),#
            helpText("Search by gene symbol; availability of a given gene is based on microarray probe annotations."),#
            downloadButton("reportDEG","Download differential gene expression analysis"),#
            helpText("This Microsoft Excel file (.XSLX) contains all differentially expressed genes among these tissues. It can be further used for downstream analyses including functional enrichment analysis.")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-by-gene Expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            # tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-by-gene Expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Violin Plot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Gene-level Expression",#
        h3("Compare genes based on absolute expression and differential expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Gene expression"),#
            checkboxGroupInput("tissues", label = "Select tissues to include",#
            choices = NULL, selected = NULL),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            checkboxGroupInput("de", label = "Choose comparison(s) to show", choices = NULL, selected = NULL),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show gene symbols (row names)", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, h4("Cluster analysis and a heatmap representation of gene expression."), p("Genes with similar expression patterns will cluster as rows, while individual microarrays cluster as columns."), uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", h4("Boxplots of expression data by tissue."), plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", h4("Boxplots of expression data by gene."), plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Sample-level Expression",#
        h3("Compare trends in samples based on experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Sample expression"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = NULL, selected = NULL),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Principle component analysis", h4("Principle component analysis (PCA) to visualize relatedness among tissues."), p("Observations are orthogonally transformed and each component accounts for as much variability in the data as possible. The first two principle components for this genelist are graphed below."), plotOutput("indPlot", height = 800)),#
            tabPanel("Component loadings plot", h4("Gene contribution to each principle component."), p("The longer the bar (in either direction) the more that gene contributes to that component."), plotOutput("contribPlot", height = 800)),#
            tabPanel("Circle variance", h4("Circle variance projections onto tissue."), p("Strongly correlated genes are projected in the same direction from the origin; the greater the distance the stronger the association."), plotOutput("varPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
tags$div(class="inputWithIcon",#
           tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")),#
           textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)"))
setwd("~/Desktop/shiny-server/receptoR_final")
shinyApp(ui,server)
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "./www/receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    id = "receptorMain",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       value ="startPanel",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolated RNA from this cell is converted to labeled cDNA, which is hybridized to an oligonucleotide probe array to measure expression."),tags$li("Each array represents a snapshot of a specific transcriptome. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our cells or tissues of interest to direct bioengineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by ",#
               actionLink("linkSearch","searching for expression data"),#
               " to design your own experiment, or by ",#
               actionLink("linkLoad","loading and analysing an existing experiment.")),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("code created by Derek Toms, Qing Yun Tong and Matthew Workentine"),#
               p("Copyright (C) 2019, code licensed under GPLv3")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Microarray Database",#
       value = "searchPanel",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching the Gene Expression Omnibus (GEO) database for publicly available transcriptome data. Depending on availability, these may be available for specific tissues or isolated cell types. In the next step, these samples will be assigned to one of three categories to determine differential expression between sample types."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           helpText("Search for multiple keywords using the boolean operators 'AND','OR','NOT', and the wildcard '*'. For example: 'liver AND hepa* NOT brain'."),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories. A minimum of two and a maximum of three categories should be defined. If you are only interested in a single sample type it is recommended that this is compared to a 'background' sample to identify enriched receptor genes."),#
#
           tags$div(class="inputWithIcon",#
           tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")),#
           textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)")),#
#
           # textInputAddon(inputId = "cat1", label = NULL, placeholder = "Category 1 (e.g., pancreatic endocrine cells)", addon = icon("circle")),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2 (e.g., photoreceptors)"),#
           tags$span(style="color:#377EB8",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),#
           tags$span(style="color:#4DAF4A",icon("circle",class="fa-2x"))#
           ),#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. \nPLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               downloadButton("report","Download Report"),#
               actionButton("downloadCEL","Process")),#
           hr(),#
               # Help banner on the bottom -------------------------#
           # h4("Help me!"),#
           p("Click ",actionLink("linkReset","here "),"to start again.")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Expression Datasets",#
        value="expressionPanel",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            uiOutput("loadUserExperiments"),#
            hr(),#
            checkboxGroupInput("genelist", "Select a receptor type to analyze", #
                  choices = NULL),#
            br(),#
            selectInput("gene", "Select additional non-receptor coding gene(s) to include in the analysis.", choices = NULL, multiple = TRUE),#
            helpText("Search by gene symbol; availability of a given gene is based on microarray probe annotations."),#
            downloadButton("reportDEG","Download differential gene expression analysis"),#
            helpText("This Microsoft Excel file (.XSLX) contains all differentially expressed genes among these tissues. It can be further used for downstream analyses including functional enrichment analysis.")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-by-gene Expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            # tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-by-gene Expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Violin Plot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Gene-level Expression",#
        h3("Compare genes based on absolute expression and differential expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Gene expression"),#
            checkboxGroupInput("tissues", label = "Select tissues to include",#
            choices = NULL, selected = NULL),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            checkboxGroupInput("de", label = "Choose comparison(s) to show", choices = NULL, selected = NULL),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show gene symbols (row names)", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, h4("Cluster analysis and a heatmap representation of gene expression."), p("Genes with similar expression patterns will cluster as rows, while individual microarrays cluster as columns."), uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", h4("Boxplots of expression data by tissue."), plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", h4("Boxplots of expression data by gene."), plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Sample-level Expression",#
        h3("Compare trends in samples based on experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Sample expression"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = NULL, selected = NULL),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Principle component analysis", h4("Principle component analysis (PCA) to visualize relatedness among tissues."), p("Observations are orthogonally transformed and each component accounts for as much variability in the data as possible. The first two principle components for this genelist are graphed below."), plotOutput("indPlot", height = 800)),#
            tabPanel("Component loadings plot", h4("Gene contribution to each principle component."), p("The longer the bar (in either direction) the more that gene contributes to that component."), plotOutput("contribPlot", height = 800)),#
            tabPanel("Circle variance", h4("Circle variance projections onto tissue."), p("Strongly correlated genes are projected in the same direction from the origin; the greater the distance the stronger the association."), plotOutput("varPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
shinyApp(ui,server)
shinyApp(ui,server)
tags$div(class="inputWithIcon",#
           tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")),#
           textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)"))
shinyApp(ui,server)
shinyApp()
shinyApp(ui,server)
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    id = "receptorMain",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       value ="startPanel",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolated RNA from this cell is converted to labeled cDNA, which is hybridized to an oligonucleotide probe array to measure expression."),tags$li("Each array represents a snapshot of a specific transcriptome. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our cells or tissues of interest to direct bioengineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by ",#
               actionLink("linkSearch","searching for expression data"),#
               " to design your own experiment, or by ",#
               actionLink("linkLoad","loading and analysing an existing experiment.")),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("code created by Derek Toms, Qing Yun Tong and Matthew Workentine"),#
               p("Copyright (C) 2019, code licensed under GPLv3")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Microarray Database",#
       value = "searchPanel",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching the Gene Expression Omnibus (GEO) database for publicly available transcriptome data. Depending on availability, these may be available for specific tissues or isolated cell types. In the next step, these samples will be assigned to one of three categories to determine differential expression between sample types."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           helpText("Search for multiple keywords using the boolean operators 'AND','OR','NOT', and the wildcard '*'. For example: 'liver AND hepa* NOT brain'."),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories. A minimum of two and a maximum of three categories should be defined. If you are only interested in a single sample type it is recommended that this is compared to a 'background' sample to identify enriched receptor genes."),#
#
           tags$div(class="inputWithIcon",#
           tags$span(style="color:#E41A1C",icon("circle",class="fa-2x")),#
           textInput("cat1", label=NULL, placeholder="Category 1 (e.g., pancreatic endocrine cells)")),#
#
           # textInputAddon(inputId = "cat1", label = NULL, placeholder = "Category 1 (e.g., pancreatic endocrine cells)", addon = icon("circle")),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2 (e.g., photoreceptors)"),#
           tags$span(style="color:#377EB8",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),#
           tags$span(style="color:#4DAF4A",icon("circle",class="fa-2x"))#
           ),#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               downloadButton("report","Download Report"),#
               actionButton("downloadCEL","Process")),#
           hr(),#
               # Help banner on the bottom -------------------------#
           # h4("Help me!"),#
           p("Click ",actionLink("linkReset","here "),"to start again.")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Expression Datasets",#
        value="expressionPanel",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            uiOutput("loadUserExperiments"),#
            hr(),#
            checkboxGroupInput("genelist", "Select a receptor type to analyze", #
                  choices = NULL),#
            br(),#
            selectInput("gene", "Select additional non-receptor coding gene(s) to include in the analysis.", choices = NULL, multiple = TRUE),#
            helpText("Search by gene symbol; availability of a given gene is based on microarray probe annotations."),#
            downloadButton("reportDEG","Download differential gene expression analysis"),#
            helpText("This Microsoft Excel file (.XSLX) contains all differentially expressed genes among these tissues. It can be further used for downstream analyses including functional enrichment analysis.")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-by-gene Expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            # tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-by-gene Expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Violin Plot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Gene-level Expression",#
        h3("Compare genes based on absolute expression and differential expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Gene expression"),#
            checkboxGroupInput("tissues", label = "Select tissues to include",#
            choices = NULL, selected = NULL),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            checkboxGroupInput("de", label = "Choose comparison(s) to show", choices = NULL, selected = NULL),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show gene symbols (row names)", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, h4("Cluster analysis and a heatmap representation of gene expression."), p("Genes with similar expression patterns will cluster as rows, while individual microarrays cluster as columns."), uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", h4("Boxplots of expression data by tissue."), plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", h4("Boxplots of expression data by gene."), plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Sample-level Expression",#
        h3("Compare trends in samples based on experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Sample expression"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = NULL, selected = NULL),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Principle component analysis", h4("Principle component analysis (PCA) to visualize relatedness among tissues."), p("Observations are orthogonally transformed and each component accounts for as much variability in the data as possible. The first two principle components for this genelist are graphed below."), plotOutput("indPlot", height = 800)),#
            tabPanel("Component loadings plot", h4("Gene contribution to each principle component."), p("The longer the bar (in either direction) the more that gene contributes to that component."), plotOutput("contribPlot", height = 800)),#
            tabPanel("Circle variance", h4("Circle variance projections onto tissue."), p("Strongly correlated genes are projected in the same direction from the origin; the greater the distance the stronger the association."), plotOutput("varPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
shinyApp(ui,server)
runApp()
install.packages("writexl")
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
q()
