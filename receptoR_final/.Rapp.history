g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
                    columnDefs=list(list(#
                    targets = "_all",#
                    render = JS(#
                        "function(data, type, row, meta) {",#
                            "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                            "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                            "}")#
                            )))))#
      # if(input$Assign==0){#
      #    return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
      #        columnDefs=list(list(#
      #        targets = "_all",#
      #        render = JS(#
      #            "function(data, type, row, meta) {",#
      #                "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
      #                "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
      #                "}")#
      #                )))))#
      # } else {#
      #    return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
      #        columnDefs=list(list(#
      #        targets = "_all",#
      #        render = JS(#
      #            "function(data, type, row, meta) {",#
      #                "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
      #                "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
      #                "}")#
      #                )))) %>%#
      #                formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      # }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.gsm = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 0) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
#
  proxy.search = dataTableProxy('searchResultsGSM')#
  observeEvent(input$addButton,{#
      proxy.search %>% selectRows(NULL)#
  }) #
#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  # proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      # proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
  output$gsm_table <- DT::renderDataTable({#
      if(input$Assign==0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$Assign,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#
  ## Assign categories#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$Assign, {#
      if (input$Assign == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$Assign, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("bong",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. PLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               actionButton("downloadCEL","Download and Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
closePool(poolGeo)
poolClose(poolGeo)
poolClose(poolGEO)
aaa<-read.csv("~/Documents/Retina/Abdullah/2019-03-29 gene expression correlation data aim 1 and aim 2.2.csv")#
aaa %>% group_by(aim) -> aaa#
#
aaa %>% filter(aim==1) %>% pull(ES.mean) -> x#
aaa %>% filter(aim==1) %>% pull(ARPE19.mean) -> y#
cor.test(x,y)
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation")#
ggsave("Aim1.pdf")
aa
aaa
aaa<-aaa[,1:5]
aaa
aaa$ES.min=aaa$ES.mean-aaa$ES.sd#
aaa$ES.max=aaa$ES.mean+aaa$ES.sd#
aaa$ARPE19.min=aaa$ARPE19.mean-aaa$ARPE19.s#
aaa$ARPE19.max=aaa$ARPE19.mean+aaa$ARPE19.s
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation")
aaa%>%filter(aim==2.2)
aaa<-read.csv("~/Documents/Retina/Abdullah/2019-03-29 gene expression correlation data aim 1 and aim 2.2.csv")#
aaa<-aaa[,1:6]
aaa %>% group_by(aim) -> aaa
aaa$ES.min=aaa$ES.mean-aaa$ES.sd#
aaa$ES.max=aaa$ES.mean+aaa$ES.sd#
aaa$ARPE19.min=aaa$ARPE19.mean-aaa$ARPE19.s#
aaa$ARPE19.max=aaa$ARPE19.mean+aaa$ARPE19.s
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation")#
ggsave("Aim1.pdf")
aaa$ES.min.log<-log(aaa$ES.min,base=2)
aaa
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") + scale_x_continuous(trans="log2")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") + scale_x_continuous(trans="log2") + scale_y_continuous(trans="log2")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") + scale_x_continuous(trans="log2") + scale_y_continuous(trans="log2")
library(qualpalr)
pal <- qualpal(n = 21, list(h = c(0, 240), s = c(0.4, 0.6), l = c(0.35, 0.65)))
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") + scale_x_continuous(trans="log2") + scale_y_continuous(trans="log2")+scale_colour_manual(name="gene symbol",values=pal$hex)
pal <- qualpal(n = 21, list(h = c(0, 240), s = c(0.2, 0.6), l = c(0.35, 0.65)))
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)
pal <- qualpal(n = 21, list(h = c(0, 240), s = c(0.5, 0.8), l = c(0.35, 0.65)))
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(breaks=c(0,1,2,3,4,5,10,20,,25))
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(breaks=c(0,1,2,3,4,5,10,20,25))
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log")+scale_y_continuous(trans="log")
ggsave("Desktop/aim1-correlation-log.pdf")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)
ggsave("Desktop/aim1-correlation-lin.pdf")
pal2 <- qualpal(n = 21, list(h = c(180,360), s = c(0.2, 0.8), l = c(0.35, 0.65)))
ggplot(aaa%>%filter(aim==2.2),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)
ggplot(aaa%>%filter(aim==2.2),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal2$hex)
ggplot(aaa%>%filter(aim==2.2),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.70\nP = 0.001", x=40,y=12.5)+ggtitle("Aim 2.2, Gene Correlation) +scale_colour_manual(name="gene symbol",values=pal2$hex)
ggplot(aaa%>%filter(aim==2.2),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.70\nP = 0.001", x=40,y=12.5)+ggtitle("Aim 2.2, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal2$hex)
ggsave("Desktop/aim2-2-correlation-lin.pdf")
?scale_x_continuous
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log")+scale_y_continuous(trans="logit")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log")+scale_y_continuous(trans="log1p)
""
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log")+scale_y_continuous(trans="log1p")
ggplot(aaa%>%filter(aim==1),aes(x=ARPE19.mean,y=ES.mean)) + geom_point(aes(colour=gene),cex=4)+geom_smooth(method="lm",colour="darkgrey")+geom_errorbar(aes(ymin=ES.min,ymax=ES.max,colour=gene))+geom_errorbarh(aes(xmin=ARPE19.min,xmax=ARPE19.max,colour=gene))+ylab("ES-derived RPE expr. (fold)")+xlab("ARPE-19 expr. (fold)") + theme_bw() + annotate("text",label="Rho = 0.44\nP = 0.048", x=25,y=8)+ggtitle("Aim 1, Gene Correlation") +scale_colour_manual(name="gene symbol",values=pal$hex)+scale_x_continuous(trans="log1p")+scale_y_continuous(trans="log1p")
??log1p
ggsave("Desktop/aim1-correlation-log.pdf")
head(aaa)
aaa%>%filter(gene=="IGF-1")
g()
poolGEO <- dbPool(#
  drv = RSQLite::SQLite(),#
  dbname = "/Volumes/ULTRA/across_array/GEOmetadb.sqlite"#
)
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"),#
                             options = list(create=TRUE))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"),#
                             options = list(create=TRUE))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"),#
                             options = list(create=TRUE, plugins = "remove_button"))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included"),#
                             options = list(create=TRUE, plugins = list("remove_button")))#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
install.packages(htmltools)
install.packages("htmltools")
library(htmltools)
addUIDep <- function(x) {#
  jqueryUIDep <- htmlDependency("jqueryui", "1.10.4", c(href="shared/jqueryui/1.10.4"),#
                                script = "jquery-ui.min.js",#
                                stylesheet = "jquery-ui.min.css")#
  attachDependencies(x, c(htmlDependencies(x), list(jqueryUIDep)))#
}#
#
shinyApp(#
  ui = fluidPage(#
    addUIDep(selectizeInput("variables", "", letters, c("a","b","c"), TRUE, #
                            options = list(plugins = list("drag_drop", "remove_button")))),#
    textOutput("variables")#
  ), #
  server = function(input, output) {#
    output$variables <- renderText(input$variables)#
  }#
)
poolCloe(poolGEO)
s(poolGEO)
poolClose(poolGEO)
q
q()
library(dplyr)#
library(tidyr)#
library(ggplot2)#
library(RColorBrewer)#
library(readr)#
library(stringr)#
library(shiny)#
library(shinythemes)#
library(shinyjs)#
library(dbplyr)#
library(DT)#
#
# Bioinformatics packages installed via biocLite:#
#source("https://bioconductor.org/biocLite.R")#
#biocLite(c('limma','annotate','genefilter','ComplexHeatmap','pheatmap','cowplot','GEOmetadb','mouse4302.db','hgu133plus2.db'))#
#biocLite(c('mixOmics','MergeMaid','GEOquery','inSilicoMerging','affy','sva','Rtsne','metaArray','testthat'))#
#
library(GEOmetadb)#
library(GEOquery)#
library(affy)#
#
library(limma)#
library(annotate)#
library(pheatmap)#
library(mixOmics)#
library(cowplot)#
#
library(pool)#
#
## 2018-12-02 not currently needed:#
    # library(genefilter)#
   #  library(ComplexHeatmap)#
   ##
   #  library(MergeMaid)#
   #  library(testthat)#
   #  library(metaArray)#
   #  library(Rtsne)#
   #  library(sva)#
#
# Microarray platform annotations:#
library(mouse4302.db) #
library(hgu133plus2.db)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
poolGEO <- dbPool(#
  drv = RSQLite::SQLite(),#
  dbname = "./../GEOmetadb.sqlite"#
)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
onStop(function() {#
  poolClose(poolGEO)#
})
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples()$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  # finishedtable <- eventReactive(input$assignButton, {#
  #   dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  # })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("bong",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. PLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               actionButton("downloadCEL","Download and Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
jscode <- '#
$(function() {#
  var $els = $("[data-proxy-click]");#
  $.each(#
    $els,#
    function(idx, el) {#
      var $el = $(el);#
      var $proxy = $("#" + $el.data("proxyClick"));#
      $el.keydown(function (e) {#
        if (e.keyCode == 13) {#
          $proxy.click();#
        }#
      });#
    }#
  );#
});#
'
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("bong",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. PLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               actionButton("downloadCEL","Download and Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
)
g<-function(){shinyApp(ui,server)}
g()
source('~/Desktop/shiny-server/receptoR_final/functions.R')
setwd('/Users/derektoms/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics')
poolGEO <- dbPool(#
  drv = RSQLite::SQLite(),#
  dbname = "/Volumes/ULTRA/across_array/GEOmetadb.sqlite"#
)
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-12_genelists.rda")
load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-12_genelists.rda")
g()
source('~/Desktop/shiny-server/receptoR_final/functions.R')
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
groups<-c("liver","pancreas") ## what is has to be for the moment
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  # groups <- c(group1,group2,group3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  groups<-c("liver","pancreas") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c("photoreceptors","RPE","whole.retina"))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c(input$cat1,input$cat2,input$cat3))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
load('~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda')
eset
pData(eset)
factor(pData(eset))
summarise(pData(eset))
levels(pData(eset))
length(pData(eset))
gather(pData(eset))
gather(pData(eset)) %>% aggregate(value)
gather(pData(eset)) %>% collapse()
gather(pData(eset)) %>% collapse(value)
gather(pData(eset)) %>% parse_factor()
gather(pData(eset)) %>% parse_factor(tissue)
gather(pData(eset)) %>% parse_factor(value)
pData(eset) %>% parse_factor(value)
pData(eset) %>% parse_factor()
pData(eset) %>% parse_factor(levels=key)
pData(eset) %>% parse_factor(levels="key")
pData(eset)
as.factor(pData(eset))
summarise(pData(eset))
summarise(pData(eset),tissue)
as.data.frame(pData(eset))
as.data.frame(pData(eset)) %>% tissue
as.data.frame(pData(eset)) ->grouping
grouping$tissue
levels(grouping$tissue)
class(grouping$tissue)
grouping
grouping$tissue <- as.factor(grouping$tissue)
grouping
grouping$tissue
levels(grouping$tissue)
levels(grouping$tissue)->groups
groups
groups[1]
tissue = as.factor(pData(eset)$tissue)
tissue
levels(tissue)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
source('~/Desktop/shiny-server/receptoR_final/functions.R')
g()
groups = levels(tissue)
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        groups = levels(tissue)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)})#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c(input$cat1,input$cat2,input$cat3))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=c(input$cat1,input$cat2,input$cat3))#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, tissues, #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","Jan 13th, 2019: As I finish working out the bugs in converting these files to the analyzed output, the downloading has been disabled. However, all annotations will be saved and processed (Jan 14-16) to be made available for analysis. Please click below to download a record of your submission.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download submission record"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to download a record of your submission and begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$downloadCEL, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to download a record of your submission and begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        downloadButton("report","Download"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  # observeEvent(input$downloadCEL, {#
  #     withProgress(#
  #         message = "Downloading and processing GSM",#
  #         {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  # })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        actionButton("process","Proceed"))))      #
  })#
  observeEvent(rv$download_flag, {#
      removeModal()#
   })#
  observeEvent(input$process, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("bong",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. \nPLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               downloadButton("report","Download Report")#
               actionButton("downloadCEL","Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
ui <- fluidPage(#
tags$head(tags$script(HTML(jscode))),#
tags$head(tags$link(rel = "stylesheet", type = "text/css", href = "receptor.css")),#
tags$head(tags$link(rel = "stylesheet", href = "https://use.fontawesome.com/releases/v5.6.3/css/all.css",  integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/", crossorigin="anonymous")#
),#
# tags$script(HTML("$('body').addClass('fixed);")),#
shinyjs::useShinyjs(),#
navbarPage("receptoR",#
    theme = shinytheme("spacelab"),#
#
# Start page  ------------------------------------------------------------------------------#
#
    tabPanel("Start here",#
       h3("Welcome to receptoR!"),#
       hr(),#
       sidebarLayout(#
           sidebarPanel(#
               # h4("An automated hypothesis generation software to identify cellular signaling pathways from transcriptomics data"),#
               p("This software allows you to browse and analyze public transcriptomics data. This is based on the idea that each cell type expresses a particular suite of cellular receptors that drive its behaviour."),#
               tags$ol(tags$li("A cell transcribes mRNA that will be translated into functional receptor proteins."),tags$li("Isolating RNA from the cell and converting it to labeled cDNA allows us to hybridize it to an probe array to measure expression."),tags$li("Each sample represents a particular transcriptomic snapshot. Thousands of these have been digitized and made publicly available."),tags$li("By mining this data, we can predict which receptors are expressed by our samples of interest to direct tissue engineering strategies.")),#
               hr(),#
               #div#
               p("There are two ways to begin using receptor, either by searching for expression data to design your own experiment, or by loading and analysing an existing experiment."),#
               # To proceed, click \'Search for datasets\', above"),#
               hr(),#
               p("(C) 2019 Derek Toms"),#
               p("License")#
               #/div#
               ),#
           mainPanel(#
               img(src="overview.png",width="100%")#
               ))#
        ),#
#
# Search for GSM  ------------------------------------------------------------------------------#
#
    tabPanel("Search Expression Data",#
       h3("Organize publicly available expression data"),#
       hr(),#
       sidebarLayout(#
       sidebarPanel(#
           # style = "position:fixed;width:30%",#
           conditionalPanel(condition="input.searchpanel==1",#
           h4("Search Expression Data"),#
           p("Begin by searching for experiments that expression data for your cell or tissue type of interest."),#
           br(),#
           radioButtons("gplSelection", "Choose species:", choices = c("Mouse (GPL1261)" = "mouse", "Human (GPL570)" = "human")),#
           tagAppendAttributes(textInput("searchText", "Enter search terms:", value = ""),`data-proxy-click` = "searchButton"),#
           actionButton("searchButton", "Search for arrays"),#
           hr(),#
           # HTML(paste("These experiments, each containing multiple biological samples, are refered to as ",span("G",style="font-weight:bold"),"EO data ",span("se",style="font-weight:bold"),"ries (GSE). Each ",span("G",style="font-weight:bold"),"EO ",span("s",style="font-weight:bold"), "a",span("m",style="font-weight:bold"),"ple (GSM) represents a digitized transcriptional snapshot.",sep="")),#
           p("Click \'Add array to experiment\' to retrieve array (GSM) information and then click on the \'Assign\' tab above to organize this data for analysis."),#
           actionButton("addButton", "Add array to experiment")),#
           conditionalPanel(condition="input.searchpanel==2",#
           h4("Define the categories that you wish to assign each sample (GSM) for comparison."),#
           p("Each sample of interest should be assigned to a category. In this way, experimental comparisons can be performed to determine differential expression between categories."),#
#
           tags$div(class="inputWithIcon",textInput("cat1", label=NULL, placeholder="Category 1"),tags$span(style="color:#E41A1C",icon("circle",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat2", label=NULL, placeholder="Category 2"),tags$span(style="color:#377EB8",icon("skull",class="fa-2x"))),#
           tags$div(class="inputWithIcon",textInput("cat3", label=NULL, placeholder="Category 3 (optional)"),tags$span(style="color:#4DAF4A",icon("bong",class="fa-2x"))),#
#
           ### https://www.aridhia.com/blog/the-sky-is-not-the-limit-embedding-raw-html-and-javascript-to-create-dynamic-ui-elements-in-shiny-applications/   #
           ### ^ this should help with dynamically adding/subtracting categories#
           hr(),#
           h4("Highlight samples, then click to Assign them to the specificed category."),#
           p("Using the table at right and the drop down menu below, click on samples and \'Assign\' them to different categories. Samples can be filtered using the search bar. \nPLEASE NOTE: once you have clicked the \'Assign\' button you will no longer be able to add arrays to your experiment."),#
           fluidRow(column(8,uiOutput("categorySelect")),#
           column(4,actionButton("assignButton", "Assign")))#
           ),#
           conditionalPanel(condition="input.searchpanel==3",#
               h4("Thank you for using receptoR!"),#
               p(" Please enter your name and any comments/bugs/questions/requests in the box below, then click the \'Download and Process\' button to retrieve the raw files from the NCBI server and process them based on their assigned categories."),#
               textAreaInput("comments","Comments",width="100%",height="100px",resize="vertical"),#
               textInput("downloadId","Download ID"),#
               downloadButton("report","Download Report"),#
               actionButton("downloadCEL","Process")),#
               hr(),#
               # Help banner on the bottom -------------------------#
               h4("Help me!"),#
               p("Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle.",style="color:#D8BFD8")#
       ),#
       mainPanel(#
           # Search GSE based on species#
        tabsetPanel(#
        tabPanel("Search", value=1,#
            h4("GEO microarrays (\'GSM\') matching your search query"), # return search here!#
            DT::dataTableOutput("searchResultsGSM")#
        ),#
        # Assign samples to categories ------------------------------------------------------#
        tabPanel("Assign", value=2,#
            h4("Assign individual arrays (GSM) to categories of your choosing"),#
            DT::dataTableOutput("gsm_table")#
        ),#
        # This will be where the CEL files are downloaded (confirmation, etc) ------------#
        tabPanel("Process", value=3,#
        h4("Please confirm samples are properly categorized before proceeding"),#
        p("Expression samples annotated:"),#
                DT::dataTableOutput("finishedtable")#
        ),#
        id = "searchpanel"#
        )#
        )#
        )#
    ),#
    # Load Gene Expression Data tab -------------------------------------#
    tabPanel("Load Experiment",#
        h3("Pick from user-defined experiments to perform analyses"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Load Experiment"),#
            selectInput(inputId="user_data",label="Select an experiment for analysis",choices=c("none"="none","Photoreceptors v RPE"="2018-04-13_app_data.rda"),selected="none"),#
            # tags$ul(tags$li(tags$span(style="color:#E41A1C", icon("circle", class="fa-2x")), "photoreceptors"), tags$li("RPE"), tags$li("whole retina")),#
            hr(),#
            uiOutput("geneListsUI"),#
            br(),#
            uiOutput("geneUI")#
        ),#
        mainPanel(#
            tabsetPanel(type="tabs",selected="Gene-level expression",#
            tabPanel("Quality control",#
            uiOutput("QC")#
        ),#
            tabPanel("Experimental design",h4("Category definitions and contrasts"),p("Coming soon!")),#
            tabPanel("Gene-level expression",#
                fluidRow(#
                column(6, h4("Average Expression"), DT::dataTableOutput("genes")),#
                column(6, h4("Gene Boxplot"), plotOutput("singleGenePlot"))#
            )))#
        )#
        )#
    ),#
    # Magnitude expression tab ------------------------------------------------------------------------------#
    tabPanel("Absolute Expression",#
        h3("Compare genes based on absolute expression"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Absolute expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            # style = "position:fixed",#
            checkboxGroupInput("tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            br(),#
            checkboxInput("de_state", label = "Show differential expressed only", value = TRUE),#
            uiOutput("de_choices"),#
            br(),#
            conditionalPanel(condition="input.absexpanel==1",#
                h5("Heatmap parameters"),#
                checkboxInput("hm_probes", "Show probe-level", value = FALSE),#
                checkboxInput("hm_gsm", "Show GSM (column names)", value = TRUE),#
                checkboxInput("hm_rownames", "Show rownames", value = TRUE),#
                checkboxInput("hm_col_cluster", "Cluster columns", value = TRUE),#
                checkboxInput("hm_row_cluster", "Cluster rows", value = TRUE),#
                numericInput("hm_width", "Plot width (px)", value = 900, min = 100, max = 2400, step = 10),#
                numericInput("hm_height", "Plot height (px)", value = 1200, min = 100, max = 2400, step = 10))#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("Heatmap", value=1, uiOutput("heatmap_ui")),#
            tabPanel("Summary boxplots", plotOutput("overallPlot", height = 600)),#
            tabPanel("By-gene boxplots", plotOutput("byGenePlot", height = 600)),#
            id = "absexpanel"#
        )#
        )#
        )#
    ),#
#
    # Mixomics tab ---------------------------------------------#
    tabPanel("Relative Expression",#
        h3("Compare genes based on relative expression between experimental groups"),#
        hr(),#
        sidebarLayout(#
        sidebarPanel(#
            h4("Relative expression"),#
            p("Bacon ipsum dolor amet chuck tongue flank bresaola corned beef hamburger leberkas pig bacon pork loin. Turducken leberkas t-bone tongue, tail frankfurter corned beef strip steak buffalo picanha beef tri-tip pork belly rump flank. Chicken cupim sausage, spare ribs prosciutto beef pork corned beef salami leberkas shankle. Andouille hamburger strip steak ground round, ham filet mignon swine kielbasa pork chop jerky.",style="color:#D8BFD8"),#
            checkboxGroupInput("pls_tissues", label = "Select tissues to inclued",#
            choices = c("photoreceptors","RPE","whole.retina"), selected = c("photoreceptors","RPE","whole.retina")#
            ),#
            checkboxInput("pls_probe", "Perform PLS-DA at probe level", value = FALSE),#
            br(),#
            h4("Gene contribution plot"),#
            uiOutput("numGenesUI"),#
            radioButtons("pls_ncomp", "Select component for gene contribution plot", choices = c(1,2)),#
            br()#
            # downloadButton("pls_download", "Download gene contribution data")#
        ),#
        mainPanel(#
            tabsetPanel(type = "tabs",#
            tabPanel("PCA Analysis", plotOutput("indPlot", height = 800)),#
            tabPanel("Circle variance", plotOutput("varPlot", height = 800)),#
            tabPanel("Loadings plot", plotOutput("contribPlot", height = 800))#
        ),#
        position = c("right","left"),#
        fluid = TRUE#
        )#
        )#
    )#
)#
)
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        actionButton("process","Proceed"))))      #
  })#
  observeEvent(input$process, {#
      removeModal()#
   })#
  observeEvent(input$process, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
Symbol = getSYMBOL(ID, "hgu133plus2.db")
Symbol = getSYMBOL(featureNames(all_eset_final), "hgu133plus2.db")
source('~/Desktop/shiny-server/receptoR_final/functions.R')
source('~/Desktop/shiny-server/receptoR_final/functions.R')
closePool(poolGEO)
poolClose(poolGEO)
poolGEO <- dbPool(#
  drv = RSQLite::SQLite(),#
  dbname = "/Volumes/ULTRA/across_array/GEOmetadb.sqlite"#
)
g()
captureStackTraces <- function(expr) {#
  withCallingHandlers(#
    expr,#
    error = function(e) {#
      if (is.null(attr(e, "stack.trace", exact = TRUE))) {#
        attr(e, "stack.trace") <- sys.calls()#
        stop(e)#
      }#
    }#
  )#
}
captureStackTraces(g())
sys.calls()
list(sys.calls())
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
      updateTabsetPanel(session = session, inputId = "searchpanel", selected = "Assign")#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        actionButton("process","Proceed"))))      #
  })#
  observeEvent(input$process, {#
      removeModal()#
   })#
  observeEvent(input$process, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      updateTabsetPanel(session = session, inputId = "searchpanel", selected = "Assign")#
      return(testTable)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        actionButton("process","Proceed"))))      #
  })#
  observeEvent(input$process, {#
      removeModal()#
   })#
  observeEvent(input$process, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
  observeEvent(input$addButton, {#
      proxy.search %>% selectRows(NULL)#
      updateTabsetPanel(session = session, inputId = "searchpanel", selected = "Assign")#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        actionButton("process","Proceed"))))      #
  })#
  observeEvent(input$process, {#
      removeModal()#
   })#
  observeEvent(input$process, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
  observeEvent(input$addButton, {#
      proxy.search %>% selectRows(NULL)#
      updateTabsetPanel(session = session, inputId = "searchpanel", selected = 2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        actionButton("process","Proceed"))))      #
  })#
  observeEvent(input$process, {#
      removeModal()#
   })#
  observeEvent(input$process, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
  observeEvent(input$addButton, {#
      proxy.search %>% selectRows(NULL)#
      updateTabsetPanel(session = session, inputId = "searchpanel", selected = 2)#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        actionButton("process","Proceed"))))      #
  })#
  observeEvent(input$process, {#
      removeModal()#
   })#
  observeEvent(input$process, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      return(testTable)#
  })#
  observeEvent(input$addButton, {#
      proxy.search = dataTableProxy('searchResultsGSM')#
      proxy.search %>% selectRows(NULL)#
      updateTabsetPanel(session = session, inputId = "searchpanel", selected = "2")#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        actionButton("process","Proceed"))))      #
  })#
  observeEvent(input$process, {#
      removeModal()#
   })#
  observeEvent(input$process, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
setwd('/Users/derektoms/Desktop/shiny-server/receptoR_final')
server <- function(input, output, session) {#
#
# Set up colour environment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  catCol <- brewer.pal(3, "Set1")#
  rowCol <-desat(catCol)#
  groups <- NULL#
  # groups <- c("group1","group2","group3") ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
  # groups<-c("photoreceptors","RPE","whole.retina") ## what is has to be for the moment#
  userID <- NULL#
# Search functions _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  ### 2019-03-04 UPDATE to SQL searching directly#
  searchGSM <- eventReactive(input$searchButton, {#
      if(input$gplSelection=='human'){#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL570';"#
      } else {#
          sql<-"SELECT * FROM appgsm WHERE description MATCH ?id1 AND gpl LIKE 'GPL1261';"#
      }#
      query<-sqlInterpolate(poolGEO,sql,id1=input$searchText)#
      queryGSM<-dbGetQuery(poolGEO,query)#
      return(queryGSM)#
  })#
#
  output$searchResultsGSM <- DT::renderDataTable({#
          searchGSM()}, options=list(searching=TRUE, pageLength=50, scrollY='60vh', columnDefs=list(list(#
              targets = c(8),#
              render = JS(#
                  "function(data, type, row, meta) {",#
                      "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                      "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                      "}") #
                      )))) ## typeof data needs to be a string, as a "NA" converted to JS "NULL" breaks things#
#
# Add sample (array) record to the current experiment _,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,__,.-'~'-.,_#
  proxy.search = dataTableProxy('searchResultsGSM')#
  testTable <- NULL#
  gsm_annotated <- eventReactive(input$addButton, {#
      testTable <<- rbind(testTable,searchGSM()[input$searchResultsGSM_rows_selected,])#
      proxy.search %>% selectRows(NULL)#
      return(testTable)#
  })#
  observeEvent(input$addButton, {#
      updateTabsetPanel(session = session, inputId = "searchpanel", selected = "2")#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
  ## Assign categories to each sample (GSM)#
#
  ## Set up reactive table to store category data#
  samples <- reactiveValues()#
  samples$df <- data.frame()#
  observeEvent(input$assignButton, {#
      groups <<- c(input$cat1,input$cat2,input$cat3) ## Use these in all following code! They should have a "name" variable for user-assigned names 2018-12-10#
      if (input$assignButton == 1) {#
        gsm_selected <- gsm_annotated()#
        gsm_selected$category <- rep("Not yet assigned", nrow(gsm_selected))#
        gsm_selected[input$gsm_table_rows_selected,"category"] <- input$selection#
        samples$df <<- gsm_selected#
      }#
      else#
      {#
        samples$df[input$gsm_table_rows_selected,"category"] <<- input$selection#
      }#
  })      #
  # ^ don't love this... would like to have the category set without a button click (maybe change to this tab), but it's working for the moment#
  output$gsm_table <- DT::renderDataTable({#
      if(input$assignButton == 0){#
         return (datatable(gsm_annotated(),options=list(searching=TRUE, pageLength=50, scrollY='60vh',## 2018-12-10 Pick which columns are necessary ^#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))))#
      } else {#
         return (datatable(samples$df,options=list(searching=TRUE, pageLength=50, scrollY='60vh',#
             columnDefs=list(list(#
             targets = "_all",#
             render = JS(#
                 "function(data, type, row, meta) {",#
                     "return type === 'display' && typeof data === 'string' && data.length > 100 ?",#
                     "'<span title=\"' + data + '\">' + data.substr(0, 100) + '...</span>' : data;",#
                     "}")#
                     )))) %>%#
                     formatStyle('category', target="row", backgroundColor=styleEqual(c(input$cat1, input$cat2, input$cat3), c(rowCol[1], rowCol[2], rowCol[3]))))#
      }#
  })#
  proxy.gsm = dataTableProxy('gsm_table')#
  observeEvent(input$assignButton,{#
      proxy.gsm %>% selectRows(NULL)#
  }) #
  # outputOptions(output, "searchResultsGSM", suspendWhenHidden = FALSE)#
  # outputOptions(output, "gsm_table", suspendWhenHidden = FALSE)#
#
  ## UI output#
#
    output$categorySelect <- renderUI(#
      fluidRow(#
        column(12,#
               selectizeInput("selection", "Select a Category",#
                           c("category1" <- {input$cat1},#
                             "category2" <- {input$cat2},#
                             "category3" <- {input$cat3},#
                             "category4" <- "Not included")#
                             # , options = list(create=TRUE, plugins = list("remove_button")))  ### <- "remove_button" isn't what I thought it was. I would also like the "create" option but I will need to link this to the table as cat1-3 are linked (otherwise new variables are not coloured or sent along for processing)#
        )#
      )     ### 2018-12-10 I'd like to have a button to add category 3#
    )#
    )  #
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
#
## Finished table, to ultimately lead to CEL download#
#
  finishedtable <- eventReactive(input$assignButton, {#
    dplyr::filter(samples$df, category %in% c(input$cat1, input$cat2, input$cat3))#
  })#
  output$finishedtable <- DT::renderDataTable({datatable(finishedtable(),#
      options=list(searching=FALSE,pageLength=100, scrollY='60vh')) %>%#
      formatStyle('category',target="row",#
      backgroundColor=styleEqual(c(input$cat1,input$cat2,input$cat3),c(rowCol[1],rowCol[2],rowCol[3]))#
  )})#
rv <- reactiveValues(download_flag = 0)#
#
  # proxy.finishedtable = dataTableProxy('finishedtable')#
  output$report <- downloadHandler(#
      filename = paste(input$downloadId,userID,"GSM_report.csv",sep="_"),#
      content = function(file){#
          write.csv(finishedtable(),file)#
#           tempReport <- file.path(tempdir(),"report.Rmd")#
#           file.copy("report.Rmd",tempReport,overwrite=TRUE)#
#           params <- list(annotatedGSM = finishedtable())#
##
#           rmarkdown::render(tempReport,output_file = file,#
#               params = params,#
#               envir = new.env(parent=globalenv())#
#               )#
rv$download_flag <- rv$download_flag + 1#
      })#
observeEvent(input$downloadCEL, {#
    showModal(modalDialog(title="Important! Downloading raw .CEL files from the NCBI server.","April 11th, 2019: App should be working now. Please click below to begin processing the data.",#
    footer = tagList(#
        modalButton("Cancel"),#
        actionButton("process","Proceed"))))      #
  })#
  observeEvent(input$process, {#
      removeModal()#
   })#
  observeEvent(input$process, {#
      withProgress(#
          message = "Downloading and processing GSM",#
          {userID<<-processData(finishedtable(),input$comments,input$gplSelection)})#
  })#
#
#  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  _  #
# ( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )( )#
# \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/ \/\ #
# (_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)(_)#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
## This is where the analysis part of the application begins#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#
observeEvent(input$user_data,{#
   if(input$user_data=="none"){#
        mapped_probes<<-NULL#
        eset<<-NULL#
        de_choices<<-NULL#
        sig_genes_lfc<<-NULL#
    }else{#
        # withProgress(message="Dataset loading",value=0.4,{load("../2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        # withProgress(message="Dataset loading",value=0.4,{load("~/Documents/Retina/CNIB_TuckMacPhee/Bioinformatics/2018-04-13_app_data.rda",envir=.GlobalEnv)})#
        withProgress(message="Dataset loading",value=0.4,{load("~/Desktop/shiny-server/receptoR_final/app_data_20190410-2123.rda",envir=.GlobalEnv)#
        tissue = as.factor(pData(eset)$tissue)#
        groups <<- levels(tissue)#
        updateCheckboxGroupInput(session, "tissues", #
            choices = groups, selected = groups)#
        updateCheckboxGroupInput(session, "pls_tissues", #
            choices = groups, selected = groups)#
    })#
    }#
})#
#
# Load genes tab ------------------------------------------------------------------------------#
#
  geneList = reactive({#
    if (is.null(input$genelist) && is.null(input$gene)) {#
      return(NULL)#
    }#
    genes = c()#
#
    if (!is.null(input$genelist)) {#
      for (gene in input$genelist) {#
        genes = c(genes, gene_lists[[gene]])#
      }#
    }#
#
    if (!is.null(input$gene)) {#
      genes = c(genes, input$gene)  #
    }#
    return(unname(genes))#
  })#
  # gene list UI#
  output$geneListsUI = renderUI({#
    checkboxGroupInput("genelist", "Select a receptor type to analyze", #
          choices = names(gene_lists))#
  })#
  # single gene UI#
  output$geneUI = renderUI({#
    withProgress(message="Loading gene lists",value=0.6,{selectInput("gene", "Select gene(s) to show", choices = all_genes, multiple = TRUE)})#
  })#
#### This was key to loading the output before we get to this page. All that remains now is either loading both human and mouse, or loading just one depending on the species button. I think loading both at the beginning will help it be snappier overall...#
  outputOptions(output, "geneUI", suspendWhenHidden = FALSE)#
 summary_gene_data = reactive({#
   validate(#
      need(geneList(), "No genes selected"),#
      need(!is.null(eset),"No dataset selected")#
    )#
   get_expression_summary(eset, geneList())#
 })#
 output$QC = renderUI({#
    validate(#
      need(input$user_data!="none","No dataset selected")#
    )#
    fluidRow(h4("Expression normalization (array intensity, before and after)"), tags$img(src="array-processing.png",width="100%"), h4("RNA degradation plot (probe position vs intensity)"),#
    tags$img(src="RNA-deg.png",width="100%"))#
  })#
  output$genes = DT::renderDataTable({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
     summary_gene_data() %>% datatable() %>% #
      formatRound(2:4)#
  })#
  # single gene plot#
 output$singleGenePlot = renderPlot({#
  # output$singleGenePlot = renderTable({#
    validate(#
      need(input$genes_rows_selected >= 1, "No genes selected")#
    )#
    rows = as.integer(input$genes_rows_selected)#
    genes_to_plot = summary_gene_data()$Symbol[rows]#
    gene_data = get_gene_data(eset, genes_to_plot)#
    by_gene_violplot(gene_data,tissues=groups)#
  })#
#
  # DE choices UI#
  output$de_choices = renderUI({#
    checkboxGroupInput("de", "Choose comparison(s) to show", choices = de_choices, selected = de_choices[1])#
  })#
#
# Expression tab ------------------------------------------------------------------------------#
  observe({#
    toggle("de_choices", anim = TRUE, condition = input$de_state )#
  })#
  genesToPlot = reactive({#
    validate(#
      need(geneList(), "No genes selected")#
    )#
#
    genes = geneList()#
    if(input$de_state) {#
      selected_de = input$de#
      de_lists = lapply(selected_de, function(x) { as.character(get_de_genes(genes, x, sig_genes_lfc)$Symbol) })#
      genes = Reduce(union, de_lists)#
    } #
    return(genes) #
  }) #
# heatmap plot --------------------------------------------------------------------------------#
  output$expressionPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    selected_tissues = input$tissues#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(genesToPlot(), mapped_probes)#
    gene_heatmap(sub_eset, genes, scale = "row",#
                  probe_level = input$hm_probes,#
                  gsm_show = input$hm_gsm,#
                  show_rownames = input$hm_rownames,#
                  cluster_rows = input$hm_row_cluster,#
                  cluster_cols = input$hm_col_cluster,#
                  border_color = NA)#
  })#
  output$heatmap_ui = renderUI({#
    plotOutput("expressionPlot", height = input$hm_height, width = input$hm_width)#
  })#
#
# Overall expression --------------------------------------------------------------------------#
#
  output$overallPlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    overall_expression_boxplot(gene_data, tissues = input$tissues)#
  })#
# By gene boxplots ----------------------------------------------------------------------------#
#
  output$byGenePlot = renderPlot({#
    validate(#
      need(genesToPlot(), "No genes selected"),#
      need(input$tissues, "No tissues selected")#
    )#
    gene_data = get_gene_data(eset, genesToPlot())#
    by_gene_boxplot(gene_data, tissues = input$tissues)#
  })#
  plsdaData = reactive({#
    selected_tissues = input$pls_tissues#
    if(length(selected_tissues) < 2) {#
      return(NULL)#
    }#
    sub_eset = eset[, eset$tissue %in% selected_tissues]#
    genes = gene2probe(geneList(), mapped_probes)#
    probe = input$pls_probe#
    #ncomp = input$pls_ncomp#
    get_plsda(sub_eset, genes, probe) #
  })#
#
# PCA plot ----------------------------------------------------------------------------#
  output$indPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(length(input$pls_tissues) >= 2, "Please select at least two tissues")#
    )#
    plotIndiv(plsdaData()$result, ind.names = FALSE, group = plsdaData()$tissue_grps, pch = 16, #
              col.per.group = brewer.pal(3, "Set1")[1:length(input$pls_tissues)], legend = TRUE, cex = 2, ellipse=TRUE)#
  })#
#
# Correlation Circle plot ----------------------------------------------------------------------------  #
  output$varPlot = renderPlot({#
     validate(#
      need(plsdaData(), "No PLS-DA to plot")#
    )#
#
    plotVar(plsdaData()$result, var.names = list(plsdaData()$varNames), cex = 3,overlap=FALSE)#
  })#
#
  output$numGenesUI = renderUI({#
    numericInput("pls_num_genes", "Select number of genes to show contributions for", #
                 value = 10, min = 1, max = length(geneList()), step = 1)#
  })#
# Loadings plot ----------------------------------------------------------------------------#
  output$contribPlot = renderPlot({#
    validate(#
      need(plsdaData(), "No PLS-DA to plot"),#
      need(input$pls_num_genes, "")#
    )#
    grps = plsdaData()$result$names$Y#
    cols = brewer.pal(3, "Set1")[1:length(grps)]#
    ndisplay = input$pls_num_genes#
    comp = as.integer(input$pls_ncomp)#
    plotLoadings(plsdaData()$result, name.var = plsdaData()$varNames, ndisplay = ndisplay,#
                comp = comp, legend.color = c(1:2))#
  })#
#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$#$  #
  ## Kill shinyApp when session closes#
  session$onSessionEnded(stopApp)#
#
}
g()
data = data.frame(x=c(1,2,3),y=c(6,2,9))
t(data)
data
poolClose(poolGEO)
q()
